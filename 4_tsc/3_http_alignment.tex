\section{Aligning \acs{tsc} with \acs{http}}
\label{sec:align_tsc_http}

% Otros trabajos citables parecidos a esto:
%      posiblemente el primero que expuso explicitamente semejanzas entre HTTP y primitivas de TSC: Riemer 2006 (comprobar y citar!)
%      Otros papers de TSC y la WWW, que ya han sido citados en la sección 3_tsc

This section presents our materialization of a \ac{tsc} \acs{api} over \ac{http}.
This materialization gives a practical overview of \ac{tsc}'s \acs{rest}fulness.


\subsection{\acs{tsc} resources}

Three key concepts are important to understand the resources in our proposal: agents share information in a common \textbf{space}.
A space is identified by an \acs{uri}.
Therefore, all the operations in \ac{tsc} are performed against a particular space.
%By default, all applications connect to a common standard space, but they can optionally choose to connect to a particular private space.
Within a space, the information is stored in sets of \textbf{triples} called \textbf{graphs}.
Each graph can also be identified by an \acs{uri}.
% The \acs{rdf} \textbf{triples} are the underlying concept of all the \ac{sw} languages. % a estas alturas esto está explicadísimo
Each triple is composed by a subject (which is a \acs{uri} or a \emph{blank node}), a predicate (a \acs{uri}) and an object (which can be a \acs{uri}, a \emph{blank node} or a literal), as shown in the Figure~\ref{fig:triples_example}.
% TODO cuidado con los blank nodes!!! Los tenemos en cuenta? De ser así, cómo???

As detailed later, \ac{tsc}'s primitives add or remove graphs.
% este es un tema "delicado" desde el punto de vista de TSC, así que mejor si lo tratamos a parte:
% as well as to query for graphs or for sets of triples retrieved from different graphs.
To perform these operations, which enable the selection of a subset of the semantic content hold in a given space, a \textbf{template} is required. % these operations: add or remove
The wildcard templates used are special triples with optional wildcard subject, predicate and/or object.
For example, the template \texttt{?s foaf:knows gomezgoiri:aitor} could be employed to select instances which represent people who know Aitor (see Figure~\ref{fig:tsc_resources}).

% TODO Discussión profunda de SPARQL y REST???

% "Cartoon Cloud" by egyninja is marked as "public domain": http://openclipart.org/detail/25319/cartoon-cloud-by-egyninja
\InsertFig{tsc_resources}{fig:tsc_resources}{Schematic view of a space with four graphs and sample triples for one of these graphs}{
The figure uses prefixes, i.e., aliases for the beginning of the \acp{uri}, for the sake of clarity.
}{1}{}


Note that this thesis does not consider using more sophisticated query languages like SPARQL \citeweb{sparql2008}. % sophisticated o expressive?
The rationale behind this decision is that we wanted to avoid the complexity introduced by these languages in our \ac{api}.
While the advanced query languages need to be interpreted by parsers not available in many embedded platforms,
wildcard templates are straightforward to implement and to process.
This simplicity eases the adoption of the \ac{api} by as many platforms as possible.
However, since the wildcard templates are the base for the advanced query languages, our \ac{api} could be extended to allow their use.
In any case, this extension is left as a future work.



\subsection{Adopted \acs{tsc} primitives}
\label{sec:primitives}

\acs{tsc} derives some primitives originally defined in the Linda language \citep{gelernter_generative_1985} to access the semantic information hold in each graph.

\begin{itemize}
 \item The \textbf{write} primitive allows writing a graph into a given space (identified by its \acs{uri}).
	The set of triples received by this primitive will be stored together in the same graph, returning the \acs{uri} which identifies that graph.
	The graph \acs{uri} can be used to access directly to that graph later on, or to create new triples and relate contents.
       % Esto no encaja necesariamente con el concepto de "Browsable graph": http://www.w3.org/DesignIssues/LinkedData
  \begin{lstlisting}
    write(space_URI, triples): URI              [1]
  \end{lstlisting}


  \item The \textbf{read} returns a graph belonging to a given space which contains at least a triple matching the given template or has the given \acs{uri} as its identifier.
	If more than one graph fulfils one of these conditions, just one of them is returned (nondeterministically).
	It should be remarked that it has been designed as a non blocking operation.
  \begin{lstlisting}
    read(space_URI, graph_URI): triples         [2]
    read(space_URI, template): triples          [3]
  \end{lstlisting}
  
  
% why?
% TODO READ al ser no-deterministica puede afectar a caching???
  \item The \textbf{take} primitive behaves like a destructive \textbf{read}, deleting the graph returned from the space.
  \begin{lstlisting}
    take(space_URI, graph_URI): triples         [4]
    take(space_URI, template): triples          [5]
  \end{lstlisting}

%  \item Space management primitives.
%	A node can join or leave a space using \linebreak \texttt{joinSpace(space\_URI)} or \texttt{leaveSpace(space\_URI)}.
\end{itemize}



\subsection{\acs{http} \acs{api} for \acs{tsc}}
\label{sec:httpapi}

As both \ac{tsc} and \ac{http} are \ac{rest} compliant, their similarities are evident.
In the same way \ac{tsc} has the already explained primitives, \ac{http} has verbs to get, create, update or remove resources (GET, PUT, POST, DELETE).
%The main purpose of \acs{tsc} primitives is not to access data but to coordinate the nodes accessing to that data.
Consequently, the translation between these two worlds is straightforward.

\begin{sloppypar}
According to the \ac{rest} principles the interaction with an API must be hypertext-driven \citep{fielding_rest_2008}.
To ease its usage by developers, we provide a human-oriented \acs{html} representation of the \ac{api} which is completely \emph{browseable}.
% un poco repetido de la parte de HATEOAS
Regarding the machine-oriented representation of the \ac{api}, \citet{verborgh_functional_2012} and \citet{kjernsmo_necessity_2012} have proposed solutions to enable hypermedia driven semantic \acp{api}. % mencionar que son experimentales?
Independently of the mechanism adopted, in this section we propose a optional \ac{api} which stresses \ac{tsc}'s compliance with \ac{http}.
\end{sloppypar}

The list of spaces a node is joined to are available under \textit{/spaces}.
Each space is identified by an \acs{uri} (e.g., \url{http://space1}).
If this \acs{uri} is also a \acs{url}, $/spaces/\{space\_uri\}$ (summarized by \emph{sp} from now on) can simply redirect to it.
All the resources of that space, both real (i.e., graphs) or virtual (i.e., query) are listed under $\{sp\}/$.
Each graph is available on ${\{sp\}/graph/\{graph\_uri\}}$.
If we make an \acs{http} DELETE to that resource, under \ac{tsc}'s perspective, we take that graph from the space.
The rest of the mappings are shown in the Table~\ref{tab:tscAPI}.


\input{\pathchapfour/tables/http_api}


\subsubsection{Status codes}
\label{sec:status_codes}
The \acs{api} should be compliant with the standardized \acs{http} status codes \citeweb{http2008status}.
These codes are sent back in the response as part of the header.
For instance, the \ac{tsc} middleware returns the \emph{404 error} when no significant result can be found for a primitive.
This adoption, apart from enhancing the compatibility with other web applications, can enable the modular adoption of the \ac{api}.
% Esto tiene más sentido para el outer space que para este API
For example, if a space does not offer a wildcard based \textit{read}, it can simply return a \emph{501 Not Implemented}.
The participants would then be aware of the problem and use an alternative primitive to obtain the data needed.
%Instead, they will interpret these cases as empty responses.
This modularity becomes crucial to ease the partial adoption on new platforms.


\subsubsection{Content negotiation}
Another key aspect of the \acs{http} protocol that our \acs{api} should take advantage of is the \textit{content negotiation}.
This mechanism allows to specify the desired representation for a content on the client side and to express what representation is sent as a response from the data provider side.
For that purpose, the client adds an \textit{Accept} field to the \acs{http} header with a weighted list of media types it knows how to interpret.
Then, the server will answer with the best possible format it understands, specifying the \textit{Content-type} in the response.

The benefits of using this mechanism in the \ac{tsc} middleware presented are two-fold.
Firstly, it enhances the browsability of the primitives with human understandable \acs{http} responses. % no sé si esto es de Content Negotiation per se
Secondly, it allows different semantic representations (e.g., RDF/XML \citeweb{rdfxml2004}, N-Triples \citeweb{ntriples2004} or \acs{n3} \citeweb{n32011}).
The latter characteristic becomes crucial since not all the nodes may understand all the formats (e.g., a mobile phone may not have a RDF/XML parser).
%This is true even if all the languages use the same basic concepts (i.e., \acs{rdf} Triples).
In these cases, the compatibility of both sides can be ensured through a conversion carried out in the server side.
Furthermore, expressing the preference for a semantic format can be useful too in other cases.
For example, to obtain the less verbose answer.
