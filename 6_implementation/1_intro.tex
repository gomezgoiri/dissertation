%\section{Introduction}

Integration of heterogeneous data sources or service providers is a common task in Ambient Intelligence (AmI)
applications. The development of these applications usually requires the integration of multiple sensors deployed
in the environment, the interaction with multiple actuators or gathering data from different internal or external
service providers. These tasks can be performed using ad-hoc protocols for each sensor and actuator or employing
a common gateway, such as OSGi, on top of these protocols. However, interoperability problems remain due to the
lack of automation in the consumption of foreign, unknown services. % porque HTTP?

In contrast to this, the Triple Space Computing paradigm arises as a way to enable automatic interoperability
among applications. This paradigm relies on the tuple spaces paradigm, taking some of its advantages: different
applications share information through virtual shared spaces and perform queries on them. Therefore, applications are
decoupled in different levels: a) time, since one application can store information in the common space and other
applications consume it later in an asynchronous way; b) space, since applications can run in different environments as
long as they support tuple spaces; and c) reference, since applications should not need to know where the space is
physically stored. On top of these features of tuple spaces, Triple Space Computing adds a new level of decoupling:
vocabulary, since the information is stored in a semantic format. This way, two applications using standard ontologies
can interact among them automatically enriching one each other, as long as they use the same space and standard and
linked ontologies.

The way this paradigm works is simple: each application writes semantically annotated information in a shared space,
and other applications or nodes can query for it and even take it. For instance, consider two mobile applications. The
first one retrieves information from professional social networks such as Academia.edu or LinkedIn. The application
consumes information from these social networks and it stores this information in their mobile phone through Triple
Spaces, using standard ontologies such as FOAF (Friend of a Friend) to link people or even authors of a paper written
jointly by multiple authors. Since the application uses Triple Spaces, this information is available for other nodes in
the shared space. A second and independent application may notify users when there is a friend in the same party or in
the same building. This application may populate the shared space dumping information retrieved from social networks
such as Facebook or Orkut, and looks into the space for whom is friend of this user according to the FOAF ontology. The
interoperability is achieved when a user of the second application, which does not support Academia.edu or LinkedIn,
automatically discovers a friend who is using the first application, given that both applications are sharing
information through the shared space and using the same ontology.

In order to achieve this interoperability through Triple Spaces, we propose a middleware solution, called
Otsopack. This solution provides two core features: a) it is designed to be simple, modular and extensible, and b) it
runs in different computational platforms, including Java SE and Android. The underlying interface is based on HTTP and
covers isolated features such as discovery, maintenance or data access. Different implementations can provide
only certain features and still interact with each others. This way it is possible to embed it in other platforms such
as XBee sensors that only support Python and require a partial, ad-hoc implementation.

% TODO renumerar las secciones!
The rest of the chapter is organized as follows. Section 2 outlines related work. Section 3 describes the conceptual model
for an HTTP based TS solution. Section 4 details the implementation made to adapt it to the necessities of Ambient
Intelligence needs. Section 5 explains two study cases where the middleware will be useful and measures the performance
of the middleware described. Finally, Section 6 concludes and discusses future work.
