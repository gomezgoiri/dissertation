\section{Summary and Future Work}
\label{sec:actuation_summary}

This chapter presented two ways to actuate on the physical environment.
The first is the usual way to operate through spaces and provides a higher degree of decoupling.
However, it requires participants to use our middleware's primitives. % requiere la cooperaci√≥n de los proveedores...
In other words, our middleware is not able to reuse third applications \ac{rest} services.


The second actuation mechanism directly consumes \ac{rest}ful \acs{http} \acsp{api}.
This mechanism relies in the semantic description of the services, additional knowledge and in a reasoning process. % additional knowledge: background + initial
With that information, it is able to generate executions plans towards a goal.
Following these plans implies different calls to the different services.


We implemented the same scenario using these two actuation mechanisms.
Besides, since interoperability is one of our middleware's guiding principles, we sketched how to reuse these \ac{rest}ful \acs{http} \acsp{api} in our \Space{} model in a third implementation.
This reuse avoids any alteration on the space-based consumer or the \ac{http} provider.
Instead, it improves the \Space{} implementation with an agent in charge of generating execution plans.
This agent reuses the information from the space-based actuation not to require any additional information to the developer.


This implementation alignment between our space-based actuation and the proof-based one presents some limitations.
For some of these limitations, we discuss other design alternatives and compare them with the chosen one.
The rest of the limitations only appear in more complex scenarios.


For our future work, we will implement these complex scenarios where advanced conflicts between the \ac{rest} and space-based computing worlds can arise.
Besides, this dissertation does not answer how to reuse actuation mechanisms of the nodes using \ac{ts} patterns from \ac{rest}ful \acs{http} \acsp{api}.
Specifically, it would be interesting to experimentally test what would be necessary to seamlessly use our middleware's capacities from  third \ac{wot} solutions.