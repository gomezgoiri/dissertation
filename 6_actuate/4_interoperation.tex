\section{Interoperation between Actuation Approaches} % Usage of \acs{rest} \acsp{api} from \acs{tsc}}
\label{sec:actuation_discussion}

\ac{rest} and \ac{rest}-like services constitute an emerging mechanism to directly actuate in the physical environment.
Therefore, their seamless integration opens the door to reuse the capacities of many existing devices. % interoperate
Specifically, we aim to integrate semantically described \ac{rest} services in our space-based model. % integration, reuse, alignment, close the gap
% we first need to close the gap between both approaches.
%This section aims to experimentally proof the validity of the alignment presented in the previous section.


This section explores this integration helped by the baseline scenario.
Section~\ref{sec:actuation_scn3} presents a new implementation which mixes the nodes from the implementations presented in sections \ref{sec:actuation_scn1} and \ref{sec:actuation_scn2}.
This implementation shows how the \Space{} can transparently invoke \ac{rest} services on behalf of any consumer following the \ac{ts} usage patterns. % esto es, discussion
%This lead us to analyse the adjustments required to enable their interoperation.
The following sub-sections scrutinize the strengths and weaknesses of the presented design, in conjunction with some other design alternatives. % design, alternative, etc.


\subsection{Baseline Scenario}
\label{sec:actuation_scn3}

This scenario aims to proof that our space-based middleware can easily reuse third applications' providers capacities. % easily? transparently?
The scenario presents the space and the consumer (\nodeConsSpace{}) from the second scenario, but it replaces the provider with the first scenario's one (\nodeProvRest{}).
Both nodes have a good foundation for the interoperation since they use the same vocabularies. % to describe the knowledge they manage.
However, the \nodeProvRest{} and the \nodeConsSpace{} rely on different communication mechanisms: direct communication and indirect communication.


To close the gap between both worlds, we avoid changing the participant node's implementations.
Instead, we make some few adjustments in the space implementation.
These adjustments are performed by means of an agent which resides in the same machine as the space. % TODO describe what is an agent?


This agent takes care of the tasks that \nodeConsRest{} does in the scenario 1.
\begin{enumerate*}[label=\itshape(\arabic*\upshape)]
  \item crawls the discovered \acsp{api}\footnote{The discovery process is out of the scope of this implementation.},
  \item reasons about their data to get a plan, and
  \item follows the resulting plan performing \acs{http} requests.
\end{enumerate*}
To trigger the reasoning, the agent awaits for new tasks written in the space (see Listing~\ref{lst:generic_task_subscription} for the used subscription template).
Providing that after reasoning the agent does not find a plan to achieve a task, it will write it in the space again.
This way, another node which may know how to process it may take the task. % TODO discutir porque reasoning va a tener preferencia sobre actuación indirecta!


\begin{listing}
  \input{\pathchapsix/code/scn3/generic_task_subscription.tex}
  \caption{Subscription to any task written into the space.}
  \label{lst:generic_task_subscription}
\end{listing}


Requiring new data from the developer, would impede the transparent reuse of the nodes from the first and second scenario.
Therefore, the agent reuses all the information pieces it needs:
\begin{enumerate}
  \item It uses the \nodeConsSpace{}'s subscription to the task result as a goal for the reasoning.
	In our implementation, these correspondences need a minimal mapping between N3QL \citeweb{n3ql2004} and SPARQL \citeweb{sparql2008}.
	The reason why we use both languages are the underlying frameworks: EYE \citeweb{euler} and RDFLib \citeweb{rdflib}. % TODO citar!
  \item The agent uses all the content written into the space as \emph{additional knowledge} for the reasoning process.
	This is feasible because it can locally obtain it because the agent resides in the same machine as the space.
	Otherwise, obtaining this knowledge through the network would be too consuming both in bandwidth and in time.
\end{enumerate}


% TODO poner aquí algunos indicadores de la implementación de escenarios?
%   e.g. cuando código extra ha hecho falta añadir en el tercero para que se hablen entre sí


\subsection{Obtaining Resource Descriptions}

The core of the proof-based actuation mechanisms are the resource descriptions.
They must be read from the nodes willing to actuate prior to reasoning. % obvio
This action is performed by the consumer in the first scenario and by the agent which resides in the \Space{} in the third scenario.
Both nodes crawl a given \ac{api} starting from an \ac{url} to obtain the descriptions.
The discovery of the \ac{url} is out of the scope of this chapter.
% Otra alternativa: An agent could discover the descriptions and simply write them in the coordination \Space{}.


Another alternative to discover these descriptions is to make them part of the \clues{} presented in Chapter~\ref{cha:searching}.
This option ensures that they will be available in any \consumer{}.
Besides, the static nature of these descriptions does not break the \clues{} stability assumption in which our architecture is founded. % explicar más?


In any case, this chapter focuses on the interoperability problem, not on how to obtain the descriptions.
Consequently, for the sake of clarity, we opted for the more intuitive and common alternative. % simpler / more intuitive / easier to understand
That is, we assume that a process crawls the descriptions in the background.



\subsection{Obtaining Background Knowledge}

Besides resource descriptions, \citeauthor{verborgh_ijcs_2014}'s actuation mechanism also requires an initial state and background knowledge as inputs (see Section~\ref{sec:restdesc}).
In the first scenario the consumer obtains this knowledge crawling over all the possible \acsp{api}.
In the third scenario we also add all the knowledge from the space.
This is feasible because it is located in the same machine as the agent which needs it, so does not demand any networking. % no es costoso obtenerla


However, as explained in Chapter~\ref{cha:searching}, the data in \ac{ubicomp} changes too frequently to simply crawl it from time to time.
% Reading all the space would be highly inefficient.
Crawling all the \acsp{api} each time a change needs to be done is also highly inefficient.
Hence, the approach used to obtain knowledge is a clear simplification.
This simplification is justified because this chapter is centred on the interoperability rather than in the efficient communication mechanisms.


\bigskip


A possible optimization would be to benefit from the search architecture presented in Chapter~\ref{cha:searching}.
To reduce readings on the space (i.e. network usage), we propose a procedure composed by two reasoning steps.
In the first one we only use local incomplete knowledge derived from the \clues{}.
Then, we read from the \Space{} just the knowledge needed to confirm the pre-proofs obtained in the first reasoning.
The second reasoning uses this knowledge to get real pre-proofs. % real o actual pre-proofs


% Y ahora explicado en mayor detalle:
Therefore, a node which wants to actuate over the \Space{} will need to obtain the \emph{clues} from the \ac{wp}.
%These clues, as explained before, tell what kind of content other nodes provide. % un poco redundante
Let us assume that these \emph{clues} are composed by the predicates used by the nodes which provide content. % es una de las alternativas que se planteaban
The existence of a predicate used in a premise does not necessarily imply that this rule can be used.
Nevertheless, its absence does imply that it will not be used (see Figure~\ref{fig:activation_rules}).
Therefore, we can create temporary \emph{activation rules} from \clues{} which activate those potential rules. % latter rules las que se han mencionado primero


\InsertFig{activation_rules}{fig:activation_rules}{
  Sample clues, two rules and the activation rule created from the first rule.
}{
  According to the clues shown, the second rule will never be invoked.
}{0.8}{}


An \emph{activation rule} for a rule R contains a \emph{true} in the premise.
The conclusion is made by R's premise substituting the variables with fictitious \acsp{uri} with a common prefix (see Figure~\ref{fig:activation_rules}).
These fictitious \acsp{uri} are used to distinguish when a triple should be replaced by actual knowledge from the space. % explicar mejor?



\subsection{Responsibility for Triggering the Proof-based Actuation Mechanism}
\label{sec:responsible_proof}

Section~\ref{sec:restdesc} describes two coarse-grained steps to learn how to use web \acsp{api} which use \restdesc{}:
\begin{itemize}
  \item Reasoning over the descriptions, background knowledge, an initial state and a goal state.
        The result of the reasoning process if a pre-proof, which can be seen as a tentative \emph{execution plan} to achieve the goal.
  \item Check the execution plan by following it.
\end{itemize}


% no obligamos a implementar una u otra, pero recomendamos esto: XXX
The third scenario presented in the previous section opts for triggering the reasoning process when an agent receives a notification.
Previously, it subscribes to any type of tasks written into the space.


The reasoning can be performed in any node apart from the one which holds the \Space{}:
%However, we do not adhere to any of them.
%We leave as a future work to implement and quantitatively compare them.

\begin{enumerate}
  \item Any \consumer{} interested on changing the environment could trigger the process.
	If these \consumers{} use the search mechanism presented in the Chapter~\ref{cha:searching}, they will have background knowledge about other nodes.
	This reduces the dependency on the node providing the \coordspace{}.
	However, it requires them to perform tasks such as reasoning and checking the pre-proofs.
	
	Unfortunately, the first task increases the computation and the second the network usage.
	As we already mentioned in previous chapters, these tasks severely affect to the energy consumption.
	Furthermore, some constrained platforms will not even be able to reason.
	
  \item To mitigate this problem, we could delegate this task only on the nodes able to perform such tasks.
	In fact, these nodes could follow the \emph{replicated-worker pattern}.
	They could read from the space goals to trigger the process (i.e. \emph{reasoning tasks}).
	Apart from balancing the load between all the worker nodes, any node can stop being worker at any time by not taking more \emph{tasks} (e.g. if it has low energy).
	These nodes must be \consumers{} to use the \clues{} from the search mechanism as background knowledge.
\end{enumerate}


Although both alternatives avoid the dependency on the \Space{}, the space-based actuation mechanism intrinsically depends on the \Space{}.
Therefore, it makes sense that the unavailability of the space will cause the unavailability of actuating on the space.
On the contrary, it simplifies the consumers' responsibilities, which just need to worry about writing a task in the space.



\subsection{Interoperation Weakness}

The previous sections presented various alternative designs and their likely impacts on the actuation performance.
However, none of them addresses the interoperability flaws of the third scenario.
In this regard, the simple mapping between a consumer's subscription and a goal is probably its most evident interoperability flaw.


In the third scenario both the consumer subscription to a result and a goal for the provider match.
However, there is no guarantee that the consumer will always use a subscription which matches with a goal.
For instance, the consumer could use a more general subscription and then filter the concrete tasks it wants to filter.
Even worse, there is no guarantee that the consumer will subscribe to any result.
Thus, the universality of the proposed alignment can be easily affected.
To avoid this undesired effect, any developer of a consumer node should need to take into account some good practices. % to increase the interoperability chances.


% qué pasa si el consumidor del escenario 2 no se suscribe a los resultados?
% qué pasa si se suscribe a un patrón más general?
A more universal approach would be to deduce the goal from the task. % universal, generalizable
For instance, from a task of \emph{regulate temperature to 6ºC} the \Space{} could deduce the goal state of \emph{temperature of 6ºC}.
In this case, the mapping should be either
\begin{enumerate*}[label=\itshape(\arabic*\upshape)]
  \item provided by the consumer or
  \item pre-set in the space.
\end{enumerate*}
The first choice demands to feed the \Space{} with additional information. % to the middleware
%This is very inflexible and differs little from manually programming a gateway with each provider. % REALMENTE?
The second choice assumes a concrete ontology must used or extended by the user to represent tasks.
Therefore, it would limit the freedom of choosing any vocabulary to define a task.


Since this chapter simply wants to remark the potential interoperability of the presented approaches,
we opted for selecting the automatic translation from a subscription to a goal.
The implementation of the rest of the approaches is left as future work.



\subsection{Advanced Challenges} % o Advanced Limitations

The scenario used as a guiding example is very basic.
Consequently, the interoperation example shown requires further work to check its feasibility in more advanced scenarios.
We anticipate the following challenges:
\begin{itemize}
  \item When there are two or more paths to a goal, how can we discern which one to follow?
	This problem is specific to the proof-based mechanism.
  \item How does the middleware deal with the coexistence of both mechanisms.
	When both methods can be applied, which one is triggered?
	Will one of them prevail over the second?
\end{itemize}