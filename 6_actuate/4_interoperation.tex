\section{Interoperation Example Between both Approaches}

This section aims to experimentally proof the validity of the alignment presented in the previous section.
To this end, we present two implementations of the same simple scenario.
The goal of the scenario is to remotely change the light of a lamp.

The first implementation uses the proof-based actuation mechanism presented in Section~\ref{sec:background_restdesc}.
The second implementation uses a space-based one.
Then, we mix nodes from the previous implementations and analyse the adjustments required to enable their interoperation.
Sections \ref{sec:actuation_scn1}, \ref{sec:actuation_scn2} and \ref{sec:actuation_scn3} describe these scenarios respectively.
% TODO TODO TODO The implementation is publicly available in URL.



\newcommand{\nodea}{\emph{A} node}
\newcommand{\nodeb}{\emph{B} node}
\newcommand{\nodec}{\emph{C} node}
\newcommand{\noded}{\emph{D} node}



\subsection{Scenario 1}
\label{sec:actuation_scn1}

% poner un diagrama que presente el escenario?
% En ppio no, porque sería muy sencillote, y el flujo del consumidor que es el complejo ya ha sido explicado.

The first scenario presents the following nodes:
\begin{enumerate}[label=\itshape(\alph*\upshape)]
  \item A node which exposes the lamp and its actuators through a \ac{rest} \ac{api}.
	This \ac{api} is described using \restdesc{}. % REST API seguro 100%? por si acaso decir HTTP API?
	To physically change the light value, any client must send an \acs{http} request to the resource which represents the light actuator.
	
  \item A node which directly communicates with the desired provider.
	To discern which provider's resources has to call and how to do it, this implementation reasons to obtain a plan.
	This plan determines how to fulfil the node's initial goal invoking the needed \ac{http} \acsp{api}.
	Figure~\ref{fig:flow_type_b} shows the actions performed by this type of node in detail.
\end{enumerate}



\begin{figure}
        \centering % proporción chachi: 40%, 20% y 20%
	\subfigure[\nodec] {
                \includegraphics[width=0.22\linewidth]{flowSpaceProvider}
                \label{fig:flow_type_c}
        }
	~ %add desired spacing between images, e. g. ~, \quad, \qquad etc.
          %(or a blank line to force the subfigure onto a new line)
	\subfigure[\noded] {
                \includegraphics[width=0.22\linewidth]{flowSpaceConsumer}
                \label{fig:flow_type_d}
        }
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc.
          %(or a blank line to force the subfigure onto a new line)
        \subfigure[\nodeb] {
                \includegraphics[width=0.44\linewidth]{flowRESTConsumer}
                \label{fig:flow_type_b}
        }%        
        \caption{Flow charts for the different types of nodes.}
        {Please note that \nodea{} is omitted because its operation is the usual for an \acs{http} server.} % actions, behavior, operation???
        \label{fig:flow_nodes}
\end{figure}



The \acs{http} \acs{api} provided by the \nodea{} is modelled using the following resources:
\begin{itemize}
  \item \emph{/lamp}: It provides basic information about the lamp.
  \item \emph{/lamp/actuators}: It enumerates the actuators which compose the \emph{smart lamp}.
  \item \emph{/lamp/actuators/light}: It represents the unique actuator which composes the lamp in our simple example (i.e. the lamp's light).
  \item \emph{/lamp/actuators/light/01}: It represents a concrete preference to change the light.
\end{itemize}


% Aquí estoy explicando un poco el diagrama de flujo de la figura,
% dando detalles de cómo se ha implementado y a qué me refiero con cada pieza de información
% ¿Añadir descripciones y demás aquí o ponerlas como anexo?

In order to instruct consumers on how to use the services provided, they are annotated using \restdesc{}.
The \acs{http} OPTIONS returns listings~\ref{lst:light_descpost}~and~\ref{lst:measure_descget} for \emph{/lamp/actuators/light}.
Thanks to these descriptions and to the dereferenceable \acsp{uri} \citep{sauermann_cool_2008}, starting from \emph{/lamp} any client can crawl the \acs{api} to autonomously learn how to use it. % TODO citar http://en.wikipedia.org/wiki/Dereferenceable_Uniform_Resource_Identifier
% TODO TODO TODO citar a SIMON!


\begin{listing}
  \input{\pathchapsix/code/scn1/measure_descget.tex}
  \caption{Rule which expresses that having a light sensor observation, one can obtain details about the observation through an \acs{http} GET.}
  \label{lst:measure_descget}
\end{listing}

\begin{listing}
  \input{\pathchapsix/code/scn1/light_descpost.tex}
  \caption{Rule which expresses that having a preference which is measured in luxes, one can create a light observation using the \acs{http} POST.}
  \label{lst:light_descpost}
\end{listing}


In addition to the crawled content, the \nodeb{} provides two extra pieces of information to the reasoner: a preference and a goal (see listings~\ref{lst:additional_information} and~\ref{lst:light_goal}).
The preference allows the consumer to express the interest on change a service, which may not always be feasible.
The goal drives the reasoning, which tries to extract a plan to achieve it.

\begin{listing}
  \input{\pathchapsix/code/scn1/additional_info.tex}
  \caption{A preference which expresses the interest on modifying the sensed value of a light.}
  \label{lst:additional_information}
\end{listing}

\begin{listing}
  \input{\pathchapsix/code/scn1/light_goal.tex}
  \caption{A goal which expresses the interest on modifying the value for a light.}
  \label{lst:light_goal}
\end{listing}

With that plan, the consumer just needs to complete it calling to different \acs{http} resources.
If more than a resource needs to be called, the plan may also indicate how to use the information obtained from one to use it in the next call.


\subsection{Scenario 2}
\label{sec:actuation_scn2}

% poner un diagrama que presente el escenario

The second scenario presents the following nodes:
\begin{enumerate}[resume,label=\itshape(\alph*\upshape)]
  \item A node which reacts to the tasks written into a shared semantic space.
	The node running this implementation is aware of the tasks written into the space and changes the light's value accordingly. % esto es, se suscribe a ellas
	Figure~\ref{fig:flow_type_c} shows the initialization of this type node and the process performed when a graph is detected.
	
  \item A node which writes tasks into a shared semantic space describing its desire to change the light's value.
	Figure~\ref{fig:flow_type_d} shows the actions taken by this type of node.
	As it can be seen, the process is divided in two temporarily independent processes.
	The first writes the task and the second processes the result whenever it is written in the space.
\end{enumerate}


\nodec{} first subscribes to changes in the space (see Listing~\ref{lst:task_subscription}).
Then, \noded{} writes a task to be performed (see Listing~\ref{lst:task}) and subscribes to its result.
As a consequence of the writing, \nodec{} reacts by taking the task, interpreting it, changing the environment through its actuator and writing the result.
Finally, \noded{} gets a notification of the written result, takes it and processes it.


\begin{listing}
  \input{\pathchapsix/code/scn2/task_subscription.tex}
  \caption{Subscription to preferences written in the space.}
  \label{lst:task_subscription}
\end{listing}


% dar detalles de cómo se ha implementado
To simplify the implementation of the scenario, we considered a purely centralized space.
% subscripciones SPARQL
The subscription mechanism used by the space uses SPARQL \citeweb{sparql2008}.
We offered two primitives to trigger the notifications.
The first one takes into account the knowledge from the last graph written.
% http://english.stackexchange.com/questions/2981/alternatives-to-computationally-expensive
The second primitive considers the knowledge from the whole space and hence is more computationally costly.

\begin{listing}
  \input{\pathchapsix/code/scn2/task.tex}
  \caption{The preference is conceptually equivalent to a task.}
  \label{lst:task}
\end{listing}



\subsection{Scenario 3}
\label{sec:actuation_scn3}

This scenario aims to proof that our space-based middleware can easily reuse third applications' providers capacities. % easily? transparently?
The scenario presents the space and the consumer (\noded{}) from the second scenario, but it replaces the provider with the first scenario's one (\nodea{}).
Both nodes have a good foundation for the interoperation since they use the same vocabularies. % to describe the knowledge they manage.
However, the \nodea{} and the \noded{} rely on different communication mechanisms: direct communication and indirect communication.


To close the gap between both worlds, we avoid changing the participant node's implementations.
Instead, we make some few adjustments in the space implementation.
This adjustments are performed by means of an agent which resides in the same machine as the space.


This agent takes care of the tasks that \nodeb{} does in the scenario 1.
\begin{enumerate*}[label=\itshape(\arabic*\upshape)]
  \item crawls the discovered \acsp{api}\footnote{The discovery process is out of the scope of this implementation.},
  \item reasons about their data to get a plan, and
  \item follows the resulting plan performing \acs{http} requests.
\end{enumerate*}
To trigger the reasoning, the agent awaits for new tasks written in the space (see Listing~\ref{lst:generic_task_subscription} for the used subscription template).
Providing that after reasoning the agent does not find a plan to achieve a task, it will write it in the space again.
This way, another node which may know how to process it may take the task. % TODO discutir porque reasoning va a tener preferencia sobre actuación indirecta!


\begin{listing}
  \input{\pathchapsix/code/scn3/generic_task_subscription.tex}
  \caption{Subscription to any task written into the space.}
  \label{lst:generic_task_subscription}
\end{listing}


Requiring new data from the developer, would impede the transparent reuse of the nodes from the first and second scenario.
Therefore, the agent reuses all the information pieces it needs:
\begin{enumerate}
  \item It uses the \noded{}'s subscription to the task result as a goal for the reasoning.
	In our implementation, these correspondences need a minimal mapping between N3QL \citeweb{n3ql2004} and SPARQL \citeweb{sparql2008}.
	The reason why we use both languages are the underlying frameworks: Euler \citeweb{euler} and RDFLib \citeweb{rdflib}. % TODO citar!
  \item The agent uses all the content written into the space as \emph{additional knowledge} for the reasoning process.
	This is feasible because it can locally obtain it because the agent resides in the same machine as the space.
	Otherwise, obtaining this knowledge through the network would be too consuming both in bandwidth and in time.
\end{enumerate}