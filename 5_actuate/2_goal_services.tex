
\section{Direct Consumption of \acs{rest} services}

% por qué? motivación: permitir a otras app integrarse en nuestro espacio
\ac{rest}-like services constitute an emerging mechanism to actuate in the physical environment. % REST-like, no compliant with Fielding
Therefore, their seamless integration would open the door to reuse the capacities of many existing devices. % interoperate
However, this requires applications to directly use the actuator's node \ac{http} \ac{api}.


In contrast, the actuation mechanism presented in the previous section uses the \Space{} (i.e. it is indirect).
The mechanism implies that the actuator must be aware of the content of the space.
For instance, a heater must check the space to find if a new desired temperature was written.
% lo podrá reusar a través de un intermediario
% interop era una de las cosas que queriamos cuidar
% y qué pasa con las soluciones REST que quieren usar lo nuestro?


In this section we propose to close the gap between both approaches. % TODO 
To do that, we propose to transparently invoke \ac{rest}-like services on behalf of the developer.
From her perspective, she will still use the space-based patterns presented in the previous section.
However, the middleware will be enriched with the actuation capacities of third \ac{http} \acp{api}.


To define that integration, we first explain the mechanism used to describe and select the appropriate \ac{rest} services (Section~\ref{sec:background_restdesc}).
Then we sketch this integration by answering two key elements:
\begin{itemize}
  \item How do the inputs for this mechanism relate to the ones used in the \ac{ts} patterns? (Section~\ref{sec:inputs_proof})
  \item Which node is responsible for triggering this mechanism? (Section~\ref{sec:responsible_proof})
\end{itemize}



\subsection{Background}
\label{sec:background_restdesc}

In \ac{wot} physical changes in the environment are performed by manipulating \ac{http} resources.
According to the \ac{rest} principles, a client should navigate through these resources with no prior knowledge of the \ac{api}.
% Copiar esta explicación mejor de algún lado:
The client should (1) interpret the representations provided by the server and then (2) choose the appropriate state transition from the hypertext according to its intention. % y su conocimiento básico del protocolo: CRUD


% es HATEOAS?
As explained in Section~\ref{sec:network_properties}, semantic representations do not include a native way to express the hypertext. % TODO realmente se explica?
To solve this, three solutions can be adopted:
% Unos proponen extender con ontologías
(1) to use an ontology to represent the hypertext \citep{kjernsmo_necessity_2012},
(2) to embed the hypertext independently to the representations on the \ac{http} headers \citep{erik_profile_2013}, and
(3) to provide a description of the resources using the \ac{http} OPTIONS verb \citep{verborgh_functional_2012,verborgh_ijcs_2014}.
The latter two enable to discover resources and state transitions without adding metadata to the representations.
This allows not only to describe semantic representations, but any type of formats.
Furthermore, the third option represents the most expressive one. % TODO explicar por que?


Different ways exist to describe \ac{rest} services. % mencionar WADL, etc.?
% citar a donde se hable de RESTdesc y así ya se empieza a explicar la solución de forma discreta.
\emph{RESTdesc} \citep{verborgh_functional_2012} proposes a fully semantic description.
These descriptions are rules expressed in the \ac{n3}\footnote{\url{http://www.w3.org/TeamSubmission/n3/}} language with a premise and a conclusion.
The premise expresses the requirements to invoke a \ac{rest} service.
The conclusion expresses both the \ac{rest} call that needs to be made and the description of that invocation result.


\citet{verborgh_ijcs_2014} propose a proof-based composition mechanism for Web \acp{api} using \emph{RESTdesc}.
This mechanism uses as inputs:
(1) an initial state,
(2) a goal state,
(3) Web \ac{api} descriptions using RESTdesc, and
(4) optional background knowledge.
Each of these inputs are semantically expressed and therefore, they can be processed by standard \ac{n3} reasoners.
The reasoners generate proofs about how to achieve the goal starting from the initial state using the rest of the inputs.
These proofs can be seen as steps that need to be made to reach a desired state.


\citeauthor{verborgh_ijcs_2014} distinguish between pre-proof and post-proof.
The first, are those which assume that the execution of all \acs{api} calls will behave as expected.
The latter, can be seen as a \emph{revision} of the pre-proof.
It executes the Web \acs{api} of the pre-proofs and uses actual execution results to generate a new proof.



\subsection{Inputs for the Proof-based Actuation Mechanism}
\label{sec:inputs_proof}

In \citet{verborgh_ijcs_2014}'s proposal the reasoning process uses as inputs:
an initial state,
a goal state,
Web \ac{api} descriptions using RESTdesc, and
optional background knowledge.
% inputs: clues
% goal: task


\begin{description}
  \item[The descriptions] must be read from the actuation nodes prior to reasoning. % obvio
        They can be read with a \emph{ad hoc} discovery mechanisms.
        However, in order to simplify the design of the middleware, it is sensible to use one of the already existing mechanisms:
        
        \begin{itemize}
	  \item An agent could discover the descriptions and simply write them in the coordination \Space{}. % y ahora habrá que definir que es un agente?
		Then, any node willing to reason will read them from the \Space{}.
	  \item The descriptions could be part of the \clues{} presented in Chapter~\ref{cha:searching}.
		This option ensures that they will be available in any \consumer{}.
		Besides, the static nature of these descriptions does not break the stability assumption of the \clues{}. % explicar más?
        \end{itemize}


  \item[The initial state and background knowledge] can be acquired both from the coordination space and the outer space.
	However, reading all the space would be highly inefficient.
	To reduce readings on the space (i.e. network usage), we propose a procedure composed by two reasoning steps.
	In the first one we only use local incomplete knowledge derived from the \clues{}.
	Then, we read from the \Space{} just the knowledge needed to confirm the pre-proofs obtained in the first reasoning.
	The second reasoning uses this knowledge to get real pre-proofs. % real o actual pre-proofs
	
	% Y ahora explicado en mayor detalle:
	Therefore, a node which wants to actuate over the space will need to obtain the \emph{clues} from the \ac{wp}.
	%These clues, as explained before, tell what kind of content other nodes provide. % un poco redundante
	Let us assume that these \emph{clues} are composed by the predicates used by the nodes which provide content. % es una de las alternativas que se planteaban
	The existence of a predicate used in a premise does not necessarily imply that this rule can be used.
	Nevertheless, its absence does imply that it will not be used (see Figure~\ref{fig:activation_rules}).
	Therefore, we can create temporary \emph{activation rules} from \clues{} which activate those potential rules. % latter rules las que se han mencionado primero

	\InsertFig{activation_rules}{fig:activation_rules}{
	  Sample clues, two rules and the activation rule created from the first rule.
	}{
	  According to the clues shown, the second rule will never be invoked.
	}{0.8}{}

	An \emph{activation rule} for a rule R contains a \emph{true} in the premise.
	The conclusion is made by R's premise substituting the variables with fictitious \acsp{uri} with a common prefix (see Figure~\ref{fig:activation_rules}).
	These fictitious \acsp{uri} are used to distinguish when a triple should be replaced by actual knowledge from the space. % explicar mejor?


  \item[The goal state] should be created from the task to reuse the primitives and the data from the \ac{ts}-based actuation mechanism.
	For instance, from a task of \emph{regulate temperature to 6ºC} we can deduce the goal state of \emph{temperature of 6ºC}.
	This translation is out of the scope of the dissertation.
\end{description}


\subsection{Responsibility for Triggering the Proof-based Actuation Mechanism}
\label{sec:responsible_proof}

Section~\ref{sec:background_restdesc} described two coarse-grained steps:
\begin{itemize}
  \item Reasoning over the descriptions, background knowledge, an initial state and a goal state.
        The result of the reasoning process if a pre-proof, which can be seen as a tentative \emph{execution plan} to achieve the goal.
  \item Check the execution plan by following it.
\end{itemize}


This mechanism can be performed by any node.
% no obligamos a implementar una u otra, pero recomendamos esto: XXX
In this thesis, we briefly analyze three different alternatives and their trade offs.
However, we do not adhere to any of them.
We leave as a future work to implement and quantitatively compare them.

\begin{enumerate}
  \item An agent which resides in the same machine as the \emph{coordination space} can be trigger the process. % TODO buscar su nombre bueno
	Doing so, it can locally consume the knowledge available in the \emph{coordination space}.
  \item A more flexible approach would consist of letting any \consumer{} interested on changing the environment to trigger it.
	If these \consumers{} use the search mechanism presented in the Chapter~\ref{cha:searching}, they will have background knowledge about other nodes.
	This reduces the dependency on the node providing the \emph{coordination space}. % TODO buscar su nombre bueno
	However, it requires them to perform tasks such as reasoning and checking the pre-proofs.
	While the latter increases the network usage, the first increases the computation.
	As we already mentioned in previous chapters, these tasks severely affect to the energy consumption.
	Furthermore, some resource platforms will not be even able to reason.
  \item To mitigate that problem, we could delegate that task only on the nodes able to perform such tasks.
	In fact, these nodes could follow the \emph{replicated-worker pattern}.
	They could read from the space goals to trigger the process (i.e. \emph{reasoning tasks}).
	Apart from balancing the load between all the worker nodes, any node can stop being worker at any time by not taking more \emph{tasks} (e.g. if it has low energy).
	These nodes must be \consumers{} to use the \clues{} from the search mechanism as background knowledge.
\end{enumerate}


% Poner ejemplo adaptado del paper de WoT2013?


%Proceso de suggest:

%\begin{itemize}
% \item obtener todo el conocimiento necesario para el proceso?
% \item razonamiento sobre conocimiento
% \item parsear el resultado para invocar servicios HTTP
% \item monitorizar que se ha complido el cambio?
%\end{itemize}