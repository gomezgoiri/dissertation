
\section{Coordination through the Space}



% explicar brevemente patrones
% requirements: sistema de suscripciones (out of the scope)
% escenario de ejemplo en Ubicomp


In space-based computing participants coordinate by reading and writing in a shared Space. % TODO usar define a nivel general para Space!
This encourages an uncoupled communication between applications using the same Space.

In this section we analyze how to achieve this uncoupled communication following a top-down approach.
First, we briefly explain \acl{ts}'s most common application patterns. % according to the classification of \citet{freeman_javaspaces_1999}.
Using some of these patterns, Section~\ref{sec:envisaged_scenarios} shows how to build an \ac{ubicomp} scenario.
The scenario evidences some requirements, analyzed in Section~\ref{sec:notification}, the middleware must comply with.



\subsection{\acl{ts}'s patterns}
\label{sec:ts_patterns}

According to \citet{freeman_javaspaces_1999} there are four main application patterns which can be used with \ac{ts}:

\begin{description}
  \item[Replicated-worker pattern.] In this pattern there is a master process and many worker processes which are able to compute the same task.
				    %% REDUCIENDO esto: %%
%				    The master takes a problem and divides it in tasks which are solved by any of the workers.
%				    More concretely the pattern is composed by the following steps:
% 				    \begin{enumerate}
% 				      \item The master divides a problem up into smaller tasks.
% 				      \item It writes them in the space.
% 				      \item Any of the many workers takes a task.
% 				      \item That worker computes the task.
% 				      \item It writes the result of that computation.
% 				      \item The master collects the results for the tasks it wrote.
% 				      \item Once the master has all the results, it combines them into a meaningful overall solution.
% 				    \end{enumerate}  
				    The master takes a problem, divides it in smaller tasks and writes these tasks in the space.
				    Any available worker takes a task, processes it and writes the result back on the space.
				    When all the workers have written their results, the master takes the results and combines them into a meaningful overall solution.
				    %Note that the workers accept new tasks whenever they are available and able to work.
				    %Therefore, while a worker is busy computing a big task, another one can solve many small tasks.
				    %In other words, this pattern naturally \emph{balances the load} on the space.
				    %Besides, it is \emph{scalable} since we can add more workers running in more machines without rewriting our code.
				    This pattern is scalable and naturally balances the load on the space.
  \item[Command pattern.] It encapsulates behavior in the tasks shared in the space.
			  Therefore, it requires (1) to share behavior through the space, and (2) any generic worker to be able to compute the behavior.
			  For instance, a graph in \ac{tsc} could include code in an interpreted programming language.
			  % nosotros pasamos de este jaleo
			  % hacer referencia a on-demand-code
			  %In that way, a generic worker application can compute whatever code other processes define and share through the space.
			  %This pattern is only possible in \aclp{ts} where the behavior can be described generically (e.g. in object-oriented \acp{ts}).
			  %Furthermore, the tasks to be performed over \ac{ubicomp} environments are not generically processable by any node.
			  %In contrast, each device is responsible of managing its own actuators on behalf of the rest.
			  %Therefore, this pattern will not be considered.
  \item[Marketplace pattern.] In this pattern producers (or sellers) and consumers (or buyers) of resources interact to find the best deal. % TODO cita TripCom?
			  %It should be noted that the resources are products or services which can be bought and sold.
			  %Therefore, it is not applicable to the environments considered. % o use cases
			  %esto está relacionado con el paper aquel de TripCom y con el de Simon de hace un año en WoT
  \item[Specialist patterns.] In opposition to the replicated-worker pattern, in the specialist pattern each worker is specialized.
                              Therefore each worker performs a particular task.
                              \citeauthor{freeman_javaspaces_1999} enumerates three subtypes:
			      \begin{description}
				  \item[Blackboard pattern.]
					This pattern associates the concept of the space with a \emph{blackboard}.
					Following the analogy, the master is associated with a teacher, the tasks with \emph{problems} and the specialized workers with \emph{students}.
					The blackboard pattern starts when the \emph{teacher} writes a \emph{problem} in the \emph{blackboard}.
					The \emph{students} observe the space and write their intention to contribute to solve the problem (i.e. \emph{raise their hands}).
					The \emph{teacher} selects to the expert which will make a modification.
					After the modification, the \emph{teacher} decides if they found the solution another \emph{student} should contribute.
				  \item [Trellis pattern.]
					In this pattern, the master arranges the problem into low-level, mid-level and high-level pieces.
					The workers of each level benefit from the refined data provided by the immediate level below.
				  \item [Collaborative patterns.]
					It encompasses all the patterns which allow nodes to collaborate to complete a greater task (i.e. by creating a workflow).
					%They are specific to the domain so they cannot be generalized, but it includes all the patterns where the nodes collaborate to complete a greater task
					%(e.g. by creating a workflow).
			      \end{description}
\end{description}


% Voy preparando el terreno para que se vea que los primeros son más de computación y el otro de negociación
To summarize, the replicated-worker is centered in optimizing the computation by parallelizing task.
Command pattern can be seen as an abstraction of the latter where the behavior is shipped in the tuples.
Marketplace pattern allows negotiation of two entities through the space.
% Coño! pero si el especialista te permite colaborar...
Finally, specialist patterns allow nodes with distinct capacities to cooperate towards a common goal.


% TODO un esquema dividido en 4 en el que aparecen todos los patrones explicados!!!



\subsection{Envisaged Scenarios}
\label{sec:envisaged_scenarios}

This section devises two stereotypical scenarios for home automation.
Both scenarios emphasize how devices can coordinate in a decoupled mode using some of patterns seen in the previous section. % más de uno?
%The scenarios are formed by mobile phones, and embedded platforms with sensors and/or actuators.
Specifically, we believe that the \emph{specialist patterns} best fit the needs of \ac{ubicomp} environments:
\begin{itemize}
  \item The devices in \ac{ubicomp}, often serve to very specific needs.
        For example, let us imagine a mobile phone showing a message or an embedded device turning on the lights of a room.
        %Although there may exist some redundancy in the tasks which different nodes can be accomplish, the task are not nodes are not as interchangeable as in... son tareas simples, no necesitan optimizar ni lanzar muchas
  \item These tasks are usually lightweight.
        They do not require huge computation resources, but to achieve a concrete and simple goal.
\end{itemize}
Therefore, \ac{ubicomp} generally faces a problem of collaboration between nodes with different capacities, not a computation or a negotiation problem. % se entenderá a qué me refiero con computation??


%In this pattern a master writes a task into the space and waits for its result, which is performed by some of the workers specialized in this particular task (e.g. show a message or regulate the temperature).

\bigskip

The first scenario presents a room populated with several kind of sensors such as Oracle's SunSPOTs\footnote{http://www.sunspotworld.com},
% TODO referenciado en el capítulo 4!!!!
Digi's XBee sensors with a IP gateway,
the sensors on a KNX20 domotic bus and a fan connected to a FoxG20 embedded platform to act as an actuator (see Figure \ref{fig:sensorsphoto}).
Besides, an Android application semantically stores the user's temperature preferences.
An independent node (i.e. the master node) continuously reads from the space % using \emph{read primitive}
(1) the room's temperature, and
(2) the user's desired temperature.
Note that the master node does not care about who exactly provides the temperature information.
It just takes the first available graph from the space.
When the second one is below the first one, it generates a ``\emph{decrease temperature during a certain period}'' task which can be consumed by different independent worker nodes.
In this case, the FoxG20 periodically checks for orders it can fulfill extracting them from the space. % consumes them with a \textit{take primitive}.
% zasca, acabamos de poner en bandeja que nos rechine lo de comprobar periodicamente

\medskip

%%%%% ME HE QUEDADO AQUI!!!!!

The second scenario presents an application which helps the user to avoid the sedentary lifestyle by giving him different warnings.
We considered the recommendation that states that an adult should daily walk at least 10.000 steps \citep{tudor2002taking}.
Taking into account the expected steps which should have been completed in each moment of the day, the application generates different priority level messages.

There are several nodes involved in this task.
First, an Android phone periodically writes the number of steps covered by a user in that day\footnote{http://code.google.com/p/pedometer/}.
%Besides, it writes her profile, more important to this problem: her age.
Second, there are an undefined number of devices which know how to warn the user about her unhealthy behavior.
Each device belongs to a user.


The application does not directly decides how to show these messages.
Instead, it follows the \emph{blackboard pattern} and it writes its intention to complete that \emph{problem}.

The particularity if the application is that 
These messages are shown to the user by different means to warn him about unhealthy behavior.

To achieve it, the semantic information is used to find the accelerometers embedded in a user mobile and his age.
Depending on the priority of the messages, different devices which belong to that user, defined in the ontology, look for those messages.
If the priority level is low, the user can be warned in a less intrusive way than if the priority is high. Hence, room's light brightness can be increased for low priority notifications, a chumby for normal priority ones or the message can be shown directly in his mobile phone when the user should have covered many more steps than he has walked (high priority).




\subsection{Notification mechanism}
\label{sec:notification}

All the patterns explained in the previous section are triggered when another process writes information in the space (e.g. a task or a result).
To be aware of these writings the node can either poll the space or rely on a notification mechanism.
The later is more optimal and more scalable approach.
Therefore, although it is not the main focus of this thesis, in this section we present a subscription mechanism which can be used on top of the \ac{tsc} middleware proposed.

The requirements that this mechanism needs to fulfill are the following ones:
\begin{itemize}
  \item It should be independent of \ac{tsc}'s writing and reading primitives.
	This requirement ensures that frequent writings do not lead to excessive processing in resource constrained nodes.
	The main drawback of this requirement is that a node does not now when relevant data is written in the space \emph{per se}.
	A developer needs to advertise when it writes relevant data.
  \item Any node running our solution must be able to implement this mechanism.
	In other words, it no new dependencies should be added.
  \item The new primitives should use elements the current developer is used to (i.e. templates or RDF triples).
\end{itemize}


% explicar cómo funciona
% https://otsopack.readthedocs.org/en/latest/subscriptions.html
\subsubsection{Subscription primitives}

The subscription primitives the developer should use are the following ones:
\begin{itemize}
  \item \emph{Subscribe}. The node subscribes to the given template returning an URI which identifies the subscription.
    \begin{minted}{java}
URI subscribe(space_uri, template, listener)
    \end{minted}
  \item \emph{Unsubscribe}. Unsubscribes to a subscription given its subscription URI.
    \begin{minted}{java}
void unsubscribe(space_uri, String subscriptionURI)
    \end{minted}
  \item \emph{Notify}.
    \begin{minted}{java}
void notify(space_uri, template)
    \end{minted}
\end{itemize}


\subsubsection{Deployment}

The nodes responsible of handling subscriptions and notifications are called \emph{bulletin boards}.
Other nodes belonging to the same space, discover them using a out of scope method and publish their subscriptions and notifications using their HTTP API.

Each \emph{bulletin board}:
\begin{itemize}
  \item Belongs to a space.
  \item Exposes a subscription API.
  \item Shares its subscriptions with other bulletin boards which belong to the same space.
  \item Propagates the notifications to the relevant nodes using the \emph{callback url} provided by them.
\end{itemize}


The Figure~\ref{} describes a simple subscription use case.
\begin{enumerate}
  \item N1 subscribes to BB1 with a template t1.
  \item BB1 propagates the subscription provided by N1 to BB2 and BB3
  \item N3 notifies to BB3 about t2.
  \item Since t1 matches t2, BB3 tries to notify to N1 using the callback URI provided during the subscription process.
  \item Unfortunately, the BB3 cannot notify to N1 due to unexpected network problems.
  \item BB3 propagates the notification of t2 to BB2.
  \item BB2 reaches N1, so it notifies it about t2 using the callback URI.
\end{enumerate}

% TODO poner la foto esquemática de https://otsopack.readthedocs.org/en/latest/subscriptions.html