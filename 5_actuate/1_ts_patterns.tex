
\section{Acting using \ac{ts} patterns}

The first mechanism to change the environment is based on \acp{ts} application patterns.
They enable the applications built upon the \ac{ts} coordinate in a decoupled way.
% The use of semantics here helps to 
These patterns are briefly described in the Section~\ref{sec:ts_patterns}.
This patterns require a notification mechanism which is described in the Section~\ref{sec:notification}.
Finally, the Section~\ref{sec:envisaged_scenarios} shows an example of how they could be used in a \ac{ubicomp} scenario.


\subsection{\ac{ts} patterns}
\label{sec:ts_patterns}

According to Freeman et al. \cite{freeman_javaspaces_1999} there are four main application patterns which can be used with \ac{ts}:
\begin{itemize}
 \item Replicated-worker pattern
 \item Marketplace pattern
 \item Command pattern
 \item Specialist patterns
\end{itemize}


\subsubsection{Replicated-worker pattern}

In the replicated-worker pattern there is a master process and many workers processes.
The master takes a problem and divides it in tasks which are solved by any of the workers.
More concretely the pattern is composed by the following steps:

\begin{enumerate}
  \item The master divides a problem up into smaller tasks.
  \item It writes them in the space.
  \item Any of the many workers takes a task.
  \item That worker computes the task.
  \item It writes the result of that computation.
  \item The master collects the results for the tasks it wrote.
  \item Once the master has all the results, it combines them into a meaningful overall solution.
\end{enumerate}

Note that the workers accept new tasks whenever they are available and able to work.
Therefore, while a worker is busy computing a big task, another one can solve many small tasks.
In other words, this pattern naturally \emph{balances the load} on the space.
Besides, is is \emph{scalable} since we can add more workers running in more machines without rewriting our code.

% poner un sexy diagrama sacado de Senami


\subsubsection{Command pattern}

The Command pattern encapsulates behavior in the tasks shared in the space.
In that way, a generic worker application can compute whatever code other processes define and share through the space.
This pattern is only possible in \aclp{ts} where the behavior can be described generically (e.g. in object-oriented \acp{ts}).

Furthermore, the tasks to be performed over \ac{ubicomp} environments are not generically processable by any node.
In contrast, each device is responsible of managing its own actuators on behalf of the rest.
Therefore, this pattern will not be considered.


\subsubsection{Marketplace pattern}

In the marketplace pattern producers (or sellers) and consumers (or buyers) of resources interact to find the \emph{best deal}.
It should be noted that the resources are products or services which can be bought and sold.
Therefore, it is not applicable to the environments considered. % o use cases
% citar al paper aquel de TripCom???


\subsubsection{Specialist patterns}

In opposition to the replicated-worker pattern, in the specialist pattern each worker is specialized.
Therefore each worker performs a particular task.
There are three subtypes of specialist patterns:
\begin{itemize}
  \item Blackboard pattern.
	The \emph{teacher} writes \emph{problems} (tasks) in the \emph{blackboard} (space).
	The \emph{students} observe the space and \emph{raise their hands} when they want to contribute to solve the problem.
	The \emph{teacher} selects the expert which will make a modification.
	After the modification, the \emph{teacher} decides is the solution has been found or another \emph{student} should contribute.
  \item Trellis pattern.
	The master arranges the problem into low-level, mid-level and high-level pieces.
	The workers of each level benefit from the refined data provided by the immediate level below.
  \item Collaborative patterns.
	They are specific to the domain so they cannot be generalized, but it includes all the patterns where the nodes collaborate to complete a greater task
	(e.g. by creating a workflow).
\end{itemize}



\subsection{Notification mechanism}
\label{sec:notification}

All the patterns explained in the previous section are triggered when another process writes information in the space (e.g. a task or a result).
To be aware of these writings the node can either poll the space or rely on a notification mechanism.
The later is more optimal and more scalable approach.
Therefore, although it is not the main focus of this thesis, in this section we present a subscription mechanism which can be used on top of the \ac{tsc} middleware proposed.

The requirements that this mechanism needs to fulfill are the following ones:
\begin{itemize}
  \item It should be independent of \ac{tsc}'s writing and reading primitives.
	This requirement ensures that frequent writings do not lead to excessive processing in resource constrained nodes.
	The main drawback of this requirement is that a node does not now when relevant data is written in the space \emph{per se}.
	A developer needs to advertise when it writes relevant data.
  \item Any node running our solution must be able to implement this mechanism.
	In other words, it no new dependencies should be added.
  \item The new primitives should use elements the current developer is used to (i.e. templates or RDF triples).
\end{itemize}


% explicar cómo funciona
% https://otsopack.readthedocs.org/en/latest/subscriptions.html
\subsubsection{Subscription primitives}

The subscription primitives the developer should use are the following ones:
\begin{itemize}
  \item \emph{Subscribe}. The node subscribes to the given template returning an URI which identifies the subscription.
    \begin{minted}{java}
      public String subscribe(String spaceURI, NotificableTemplate template, INotificationListener listener) throws SpaceNotExistsException, SubscriptionException;
    \end{minted}
  \item \emph{Unsubscribe}. Unsubscribes to a subscription given its subscription URI.
    \begin{minted}{java}
      public void unsubscribe(String spaceURI, String subscriptionURI) throws SpaceNotExistsException, SubscriptionException;
    \end{minted}
  \item \emph{Notify}.
    \begin{minted}{java}
      public void notify(String spaceURI, NotificableTemplate template) throws SpaceNotExistsException,  SubscriptionException;
    \end{minted}
\end{itemize}


\subsubsection{Deployment}

The nodes responsible of handling subscriptions and notifications are called \emph{bulletin boards}.
Other nodes belonging to the same space, discover them using a out of scope method and publish their subscriptions and notifications using their HTTP API.

Each \emph{bulletin board}:
\begin{itemize}
  \item Belongs to a space.
  \item Exposes a subscription API.
  \item Shares its subscriptions with other bulletin boards which belong to the same space.
  \item Propagates the notifications to the relevant nodes using the \emph{callback url} provided by them.
\end{itemize}


The Figure~\ref{} describes a simple subscription use case.
\begin{enumerate}
  \item N1 subscribes to BB1 with a template t1.
  \item BB1 propagates the subscription provided by N1 to BB2 and BB3
  \item N3 notifies to BB3 about t2.
  \item Since t1 matches t2, BB3 tries to notify to N1 using the callback URI provided during the subscription process.
  \item Unfortunately, the BB3 cannot notify to N1 due to unexpected network problems.
  \item BB3 propagates the notification of t2 to BB2.
  \item BB2 reaches N1, so it notifies it about t2 using the callback URI.
\end{enumerate}

% TODO poner la foto esquemática de https://otsopack.readthedocs.org/en/latest/subscriptions.html



\subsection{Envisaged Scenarios}
\label{sec:envisaged_scenarios}

Two stereotypical scenarios for home automation had been devised to assess our collaborative middleware proposition for heterogeneous resource-constrained devices.
In both scenarios the emphasis has been put in how those devices can coordinate in a decoupled mode thanks to it following the specialist pattern.
In this pattern a master writes a task into the space and waits for its result, which is performed by some of the workers specialized in this particular task (e.g. show a message or regulate the temperature).

On the one hand, a room has been populated with several kind of sensors such as Oracle's SunSPOTs\footnote{http://www.sunspotworld.com},
XBee sensors\footnote{http://www.digi.com/products/wireless-modems-peripherals/wireless-range-extenders-peripherals/xbee-sensors.jsp} with a IP gateway\footnote{http://www.digi.com/products/wireless-routers-gateways/gateways/connectportx2gateways.jsp},
the sensors on a KNX20 domotic bus and a fan connected to a FoxG20\footnote{http://www.acmesystems.it} embedded platform to act as an actuator (see Figure \ref{fig:sensorsphoto}).
Besides, an Android application has been performed to semantically store the user's temperature preferences.
An independent node (master node) continuously checks the room temperature using \textit{read primitive} to get the first available graph where the last measure is defined (no matter which device provides that information) and the user's desired temperature.
When the second one is below the first one, it generates a ``decrease temperature during a certain period'' task which can be consumed by different independent worker nodes.
In this case, the FoxG20 periodically checks just for orders it can fulfill and it understands and consumes them with a \textit{take primitive}.

On the other hand, a message delivery system has been designed using TS in order to avoid the sedentary lifestyle of a certain user by giving him different warnings.
Taking into account the expected steps which should have been completed in each moment of the day (10.000 steps are recommended in average for an adult \cite{tudor2002taking}), different priority level messages are created to warn the user about his situation.
To figure out this, a master node reads the number of steps covered by a user in that day\footnote{http://code.google.com/p/pedometer/} and his age both from the TS node deployed on his Android phone.
To achieve it, the semantic information is used to find the accelerometers embedded in a user mobile and his age. Depending on the priority of the messages, different devices which belong to that user, defined in the ontology, look for those messages.
If the priority level is low, the user can be warned in a less intrusive way than if the priority is high. Hence, room's light brightness can be increased for low priority notifications, a chumby for normal priority ones or the message can be shown directly in his mobile phone when the user should have covered many more steps than he has walked (high priority).