%    propiedades aportadas por REST a IoT

\section{On the \acs{rest}fulness of \acs{tsc}}
\label{sec:tsc_restfulness}

\subsection{\acl{rest}}
\label{sec:rest}

\acf{rest} is an architectural style proposed by \citet{fielding_architectural_2000}.
% descripción de propiedades de REST: hipermedia distribuído
% que es hipertexto? http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven#comment-718
It aims to cover certain properties, explained in Section~\ref{sec:network_properties}.
% Estilos de los que se deriva: ¿?
To achieve these properties, \ac{rest} establishes the following constraints from other network-based architectural styles:
% explicarlo o es demasiado obvio?
\begin{description}
 \item[Client-server (CS)]
 \item[Stateless (S)] the state is fully stored in the client and therefore each request has all the information needed to process it.
 \item[Cache (\$)] when added to the CS constraint, this style replicates content obtained from a server in the client.
 \item[Uniform interface (U)] is the key constraint which distinguishes \ac{rest} from other architectural styles.
                   This constraint is composed by the following ones:
    \begin{description}
	% explicados en sección 5.2 de Fielding, resumir?
	\item[Identification of resources (ID):]
		    Resources are the conceptual targets of hypertext references.
		    Their identification offers a generic interface to access and change the values of a resource.
	\item[Manipulation of resources through representations (REP):]
		    Representations are composed by a sequence of bytes and the metadata to describe those bytes.
	\item[Self-descriptive messages (DESC):] % TODO explicar esto bien
	% : interaction is stateless between requests,
	% standard methods and media types are used to indicate semantics and exchange
	% information, and responses explicitly indicate cacheability.
	\item[Hypermedia as the engine of application state (HATEOAS):] % TODO explicar esto bien
    \end{description}
 \item[Layered system (L)] each layer provides services to the top layer (e.g. TCP/IP). % TODO usar acrónimo!
 \item[Code-On-Demand (COD)] the client has a set of resources which does not know how to process.
       That \emph{know-how} is downloaded from the server.
\end{description}


% Furthermore, \citeauthor{fielding_architectural_2000} remarks the following features as \textbf{musts} a \ac{rest} solution contains\citep{fielding_rest_2008}:
% descripción de requisitos REST: untangled

% A REST API should not be dependent on any single communication protocol, though its successful mapping to a given protocol may be dependent on the availability of metadata, choice of methods, etc. In general, any protocol element that uses a URI for identification must allow any URI scheme to be used for the sake of that identification. [Failure here implies that identification is not separated from interaction.]
% A REST API should not contain any changes to the communication protocols aside from filling-out or fixing the details of underspecified bits of standard protocols, such as HTTP’s PATCH method or Link header field. Workarounds for broken implementations (such as those browsers stupid enough to believe that HTML defines HTTP’s method set) should be defined separately, or at least in appendices, with an expectation that the workaround will eventually be obsolete. [Failure here implies that the resource interfaces are object-specific, not generic.]
% A REST API should spend almost all of its descriptive effort in defining the media type(s) used for representing resources and driving application state, or in defining extended relation names and/or hypertext-enabled mark-up for existing standard media types. Any effort spent describing what methods to use on what URIs of interest should be entirely defined within the scope of the processing rules for a media type (and, in most cases, already defined by existing media types). [Failure here implies that out-of-band information is driving interaction instead of hypertext.]
% A REST API must not define fixed resource names or hierarchies (an obvious coupling of client and server). Servers must have the freedom to control their own namespace. Instead, allow servers to instruct clients on how to construct appropriate URIs, such as is done in HTML forms and URI templates, by defining those instructions within media types and link relations. [Failure here implies that clients are assuming a resource structure due to out-of band information, such as a domain-specific standard, which is the data-oriented equivalent to RPC's functional coupling].
% A REST API should never have “typed” resources that are significant to the client. Specification authors may use resource types for describing server implementation behind the interface, but those types must be irrelevant and invisible to the client. The only types that are significant to a client are the current representation’s media type and standardized relation names. [ditto]
% A REST API should be entered with no prior knowledge beyond the initial URI (bookmark) and set of standardized media types that are appropriate for the intended audience (i.e., expected to be understood by any client that might use the API). From that point on, all application state transitions must be driven by client selection of server-provided choices that are present in the received representations or implied by the user’s manipulation of those representations. The transitions may be determined (or limited by) the client’s knowledge of media types and resource communication mechanisms, both of which may be improved on-the-fly (e.g., code-on-demand). [Failure here implies that out-of-band information is driving interaction instead of hypertext.]



\subsection{Suitable Protocols for \ac{rest}}
\label{sec:protocols}

% hablar un poco de HTTP y CoAP y decir por qué no hablamos más a menudo de CoAP

Historically, \acf{http} has been considered a suitable protocol to follow the \ac{rest} style. % TODO cite
\ac{http} is a simple protocol whose adoption by computing platforms is massive.


However, in the last few years \acf{coap} has emerged as a specialized web transfer protocol for resource constrained devices. % has emerged, has arisen?
Some noteworthy features of \ac{coap} are
(1) the reduced message size,
(2) the use of UDP as a transport layer (with the possibility of using \emph{multicast} communication),
(3) similarity with \ac{http} (both to reuse its properties and to ease cross-protocol proxying),
(4) a resource discovery mechanism. % TODO cita a CORE
% mencionar seguridad?


One could defend that to design a lightweight \ac{tsc} solution \ac{coap} should be used as a baseline.
However, we have chosen to work with \ac{http} for the following reasons:
\begin{itemize}
  \item RDF-based media-formats can be rather verbosed.
	This contrasts with \ac{coap}'s message size limitations.
	Dealing with this limitations was not one main goals of the thesis.
	However, we have considered them at some points of the dissertation to avoid unrealistic assumptions.
  \item \ac{coap} is an ongoing standard.
        Therefore, its definition slightly changes in each draft version.
        A practical limitation of this is that at the moment there are few libraries
        and tools to work with \ac{coap}.
        This limits the range of platforms which could adopt any solution proposed.
  \item Due to its similarities with \ac{coap}, the future adoption of the latter should be relatively straightforward.
        % sin contar con los aspectos destacados anteriormente
\end{itemize}

% Ideas no usadas:
% REST no dice nada, pero de facto el protocolo es HTTP
% durante el desarrollo de esta tesis en resource constrained ha surgido CoAP
%   muchas de las cosas aquí comentadas son iguales o mejor sobre CoAP
%   de todas formas, ha habido algo que ha guiado nuestro diseño: librerias existentes => afecta a plataformas
%         si, pero para eso está lo de layered approach! => motivos prácticos



\subsection{\acl{tsc}}
\label{sec:tsc_vs_rest}

\ac{tsc} consist of a shared space which is accessed using some known primitives.
\emph{Per se}, \ac{tsc} does not contradict in any sense the \ac{rest} principles:

\begin{description}
 \item[CS:] Providing the access to each space is centralized in a machine, clients can access to it using \emph{CS}.
           This does not prevent to use a distributed semantic repository in the backend.
 \item[S:] The primitives to access the space imply simple read and writes which do not store any state in the server.
 \item[\$:] The semantic content stored in the space can be cached.
           However, the dynamism of the underlying network makes caching challenging to configure. % quería poner "tune up" pero "configure" me ha sonado más fino
 \item[U:]
    \begin{description}
	\item[ID:] There are types of identified resources in \ac{tsc}: spaces, RDF Graphs and certain elements of the RDF Triples.
	                 All of them are identified by URIs.
	                 The space can be seen as a coarse-grained view of the underlying graphs. % TODO coarse grained es lo contrario de fine-grained?
	                 The graphs have sets of triples which are usually related and describe a unit of knowledge. % A RDF triple by itself cannot transmit too much information
	                 Self-identified triple's subjects, predicates or objects are the source of concept linking.
	\item[REP:] The RDF graphs and triples mentioned above can be represented using different standard serializations.
	\item[DESC:] The messages derived from the primitives can be self-describing. % including meta-data
	\item[HATEOAS:] This is the most challenging property to achieve with RDF-based representations.
	                      However, some relevant solutions propose means to fulfill this property \cite{verborgh_functional_2012}. % TODO citar más de este y de otros que han hablado LOD, SPARQL y RESTful
    \end{description}
 \item[L:] encapsulation of functionalities can be achieved through a layered system.
 \item[COD:] Although it may not be as common as scripting in ordinary human-browsing, % TODO reexplicar esto mejor?
            the \emph{know how} can be downloaded from the server:
            \begin{enumerate}
	      \item Modeling it through ontologies.
	      \item Through semantically expressed rules which are processed with an inference engine (e.g. N3 rules) \citep{verborgh_functional_2012}.
            \end{enumerate}
\end{description}

% CITAR:
% Algunas ideas rescatables de la anterior intro:
% Both \ac{wot} and \ac{tsc} can be considered resource oriented solutions since they put emphasis in giving access to data resources.
% While \ac{tsc} enables expressive queries, dynamic discovery and non human-mediated cooperation among objects, the \ac{wot} adopts the scalable properties of the World Wide Web and it is entirely based on web standards.



\subsection{Aligning \acs{tsc} with \acs{http}}

% TODO Revisar cosas del texto original que no encajaban aquí (están comentadas)
% TODO citar trabajos de:
%      TSC es como Web para semántica
%      RESTful semántico
%      So far, the compatibility of \ac{tsc} with the \acs{http} RESTful style has been proved from a formal \cite{hernandez_formal_2010} point of view.
%      Papers sobre TSC y su discurso sobre la WWW

In this section, we present a \ac{tsc} \acs{api} over \ac{http} to give a practical overview of \ac{tsc}'s \acs{rest}fulness.

\subsubsection{\acs{tsc} resources}

Three key concepts are important to understand the resources: agents share information in a common \textbf{space}.
A space is identified by an \acs{uri}.
Therefore, all the operations in \ac{tsc} are performed against a particular space.
%By default, all applications connect to a common standard space, but they can optionally choose to connect to a particular private space.
Within a space, the information is stored in sets of \textbf{triples} called \textbf{graphs}.
Each graph can also be identified by an \acs{uri}.
The \acs{rdf} \textbf{triples} are the underlying concept of all the \ac{sw} languages.
Each triple is composed by a subject (which is a \acs{uri}), a predicate (also a \acs{uri}) and a value (which can be a \acs{uri} or a literal), as shown in the Figure~\ref{fig:triples_example}.

As detailed later, most common operations in \ac{tsc} attempt to add or remove graphs.
% este es un tema "delicado" desde el punto de vista de TSC, así que mejor si lo tratamos a parte:
% as well as to query for graphs or for sets of triples retrieved from different graphs.
In order to perform the queries, which enable the selection of a subset of the semantic content hold in a given space, a \textbf{template} is required.
The wildcard templates used by default
\footnote{
  % Por qué no SPARQL?
  More sophisticated query languages like SPARQL (\url{http://www.w3.org/TR/rdf-sparql-query/}) could be used. % sophisticated o expressive?
  However, not many embedded platforms have parsers for these languages available.
  This could be an obstacle for the adoption of the middleware.
  Therefore, we have opted for using wildcard templates, which are in turn much more simple to process.
  In any case, the nodes able to parse these query languages can easily decompose a query on wildcard templates.
}
are special triples with optional wildcard subject, predicate and/or object.
For example, the template \texttt{?s foaf:knows gomezgoiri:aitor} could be employed to select instances which represent people who know Aitor (see Figure~\ref{fig:tsc_resources}).

% TODO Discussión profunda de SPARQL y REST???

\InsertFig{tsc_resources}{fig:tsc_resources}{
  Schematic view of a space with four graphs and sample triples for one of these graphs.
}{
  Aliases for the beginning of most URIs, known as prefixes in most Semantic languages, are used for the lack of clarity.
}{1}{}


\subsubsection{Adopted \acs{tsc} primitives}
\label{sec:primitives}

\acs{tsc} derives some primitives originally defined in the Linda language \citep{gelernter_generative_1985} to access to the semantic information hold in each graph.
In this section, we explain these primitives.

\begin{itemize}
 \item The \textbf{write} primitive allows writing a graph into a given space (identified by its \acs{uri}).
	The set of triples received by this primitive will be stored together in the same graph, returning the \acs{uri} which identifies that graph.
	The graph \acs{uri} can be used to access directly to that graph later on, or to create new triples and relate contents.

  \begin{lstlisting}
    write(space_URI, triples): URI              [1]
  \end{lstlisting}


  \item The \textbf{read} returns a graph belonging to a given space which contains at least a triple matching the given template or has the given \acs{uri} as its identifier.
	If more than one graph fulfill one of these conditions, just one of them is returned (nondeterministically).
	It should be remarked that it has been designed as a non blocking operation.
% why?
% TODO READ al ser no-deterministica puede afectar a caching???
  \item The \textbf{take} primitive behaves like a destructive \textbf{read}, deleting the graph returned from the space.

  \begin{lstlisting}
    read(space_URI, graph_URI): triples         [2]
    read(space_URI, template): triples          [3]
    take(space_URI, graph_URI): triples         [4]
    take(space_URI, template): triples          [5]
  \end{lstlisting}

%  \item Space management primitives.
%	A node can join or leave a space using \linebreak \texttt{joinSpace(space\_URI)} or \texttt{leaveSpace(space\_URI)}.
\end{itemize}



\subsubsection{\acs{http} \acs{api} for \acs{tsc}}
\label{sec:httpapi}

As both \ac{tsc} and \ac{http} are \ac{rest} compliant, their similarities are evident.
In the same way \ac{tsc} has the already explained primitives, \ac{http} has verbs to get, create, update or remove resources (GET, PUT, POST, DELETE).
%The main purpose of \acs{tsc} primitives is not to access data but to coordinate the nodes accessing to that data.
Consequently, the translation between these two worlds is straightforward.

\begin{sloppypar}
According to the \ac{rest} principles the interaction with an API must be hypertext-driven \citep{fielding_rest_2008}.
Therefore, the human-oriented representation of the \ac{api} should be completely \emph{browseable} (e.g. using \acs{html}).
Regarding the machine-oriented (i.e. semantic) representation of the \ac{api}, several solutions to enable hypermedia driving have been proposed by \citet{verborgh_functional_2012} and \citet{kjernsmo_necessity_2012}. % mencionar que son experimentales?
Independently of the mechanism adopted, in this section we propose a optional \ac{api} which tries to stress \ac{tsc}'s compliance with \ac{http}.
\end{sloppypar}

The list of spaces a node is joined to are available under \textit{/spaces}.
Each space is identified by an \acs{uri} (e.g. \url{http://space1}).
All the resources of that space, both real (i.e. graphs) or virtual (i.e. query) are listed under $/spaces/\{space\_uri\}$ (summarized by \emph{sp} from now on).
Each graph is available on ${\{sp\}/graph/\{graph\_uri\}}$.
If we make an \acs{http} DELETE to that resource, under \ac{tsc}'s perspective, we take that graph from the space.
The rest of the mappings are shown in the Table~\ref{tab:tscAPI}.

\begin{table} %http://en.wikibooks.org/wiki/LaTeX/Floats,_Figures_and_Captions#Wide_figures_in_two_column_documents
  \centering
  \caption {
    \acs{http} mapping for the primitives detailed in the Section~\ref{sec:primitives}. \textit{sp} is a space \acs{uri},
    \textit{g} is a graph \acs{uri}, \textit{s}, \textit{p} and \textit{o-uri} are subject, predicate and object \acsp{uri} or wildcards (represented with an as \textit{*}).
    When the template's object is a literal, it can be expressed specifying its value (\textit{o-val}) and its type (\textit{o-type}).
    \medskip
  }
  \begin{tabular}{c|l|c}
      \acs{http} request & \acs{url} & Returns \\
      \hline
      POST & \{sp\}/graphs/ & [1] \\
      GET & \{sp\}/graphs/\{g\} & [2] \\
      GET & \{sp\}/graphs/wildcards/\{s\}/\{p\}/\{o-uri\} & [3] \\
      & \{sp\}/graphs/wildcards/\{s\}/\{p\}/\{o-type\}/\{o-val\} & \\
      DELETE & \{sp\}/graphs/\{g\} & [4] \\
      DELETE & \{sp\}/graphs/wildcards/\{s\}/\{p\}/\{o-uri\} & [5] \\
      & \{sp\}/graphs/wildcards/\{s\}/\{p\}/\{o-type\}/\{o-val\} & \\
  \end{tabular}
  \label{tab:tscAPI}
\end{table}


\paragraph{Status Codes}
\label{sec:status_codes}
The \acs{api} should be compliant with the standardized \acs{http} status codes.
These codes are sent back in the response as part of the header.
For instance, the \ac{tsc} middleware returns the 404 error when no significant result can be found for a primitive.
This adoption, apart from enhancing the compatibility with other web applications, could enable the modular adoption of the API.
For example, if a node does not offer a wildcard based \textit{query}, it will not affect the behavior of the rest of the nodes of an space.
Instead, they will interpret these cases as empty responses.
This modularity becomes crucial to ease the partial adoption on new platforms.

\paragraph{Content Negotiation}
Another key aspect of the \acs{http} protocol the \acs{api} should take advantage of is the \textit{content negotiation}.
This mechanism allows to specify the desired representation for a content on the client side and to express what representation is sent as a response from the data provider side.
For that purpose, the client adds an \textit{Accept} field to the \acs{http} header with a weighted list of media types it understands.
Then, the server will answer with the best possible format it knows about, specifying the \textit{Content-type} in the response.

The benefits of using this mechanism in a \ac{tsc} middleware are two-fold.
Firstly, it enhances the browsability of the primitives with human understandable \acs{http} responses.
Secondly, it allows different semantic representations (e.g. RDF/XML\footnote{\url{http://www.w3.org/TR/REC-rdf-syntax/}}, N-Triples\footnote{\url{http://www.w3.org/2001/sw/RDFCore/ntriples/}} or N3\footnote{\url{http://www.w3.org/TeamSubmission/n3/}}).
The latter characteristic becomes crucial since not all the nodes may understand all the formats (e.g. a mobile phone may not have a RDF/XML parser).
%This is true even if all the languages use the same basic concepts (i.e. \acs{rdf} Triples).
In these cases, the compatibility of both sides can be ensured through a conversion carried out in the server side.
Furthermore, expressing the preference for a semantic format can be useful too in other cases.
For example, to obtain the less verbose answer.