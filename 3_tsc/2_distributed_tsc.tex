\section{Distributed \ac{tsc}}
\label{sec:distributed_tsc}

% cómo y porqué hacer un TSC distribuído
In Section~\ref{sec:tsc_vs_rest} section we showed how \ac{tsc} can comply with all the constraints of the \ac{rest} style.
One of these constraints is that the access to a space is done in client-server basis.
The easiest way to achieve this constraint is by centralizing all the content of each space in the server itself.


% Pero un entorno Ubicomp es eminentemente distribuído
However, the data in a \ac{ubicomp} environment is not generated in a single point.
%   La información se genera en fuentes separadas, ¿cómo accedo a los últimos datos?
In fact, each sensor in an intelligent environment is potentially generating data constantly.
Besides, the magnitude of this sensors can be enormous.
This creates a trade off between efficiency and update difficult to overcome:
\begin{itemize}
  \item The more frequently each sensor sends contents to the server, the more inefficient is the solution in terms of network usage.
  \item The less frequent this communication is, the less updated is the data in the server.
        This leads to spaces which misrepresent the environments.
\end{itemize}
A sensitive solution is to let these sensor manage their own information.


%   ademas no practico:
%        las fuentes del conocimiento son las que mejor saben como gestionar una informacion (crearla, acualizarla o eliminarla)
%        la información se transporta en dispositivos
%        reusar datos en distintas apps
Furthermore, this strategy can not only be useful for devices which constantly generate new data.
Delegating responsibilities between the devices presents additional benefits:
\begin{itemize}
  \item They will know how to represent these contents better than others. % ejemplo en grados centigrados o celsius?
	For example, the unit of a temperature measure.
  \item They know when to create, update or delete data. % ejemplo if a server receives 2 contradictory measures... algo
        In fact, they can opt for creating data on demand.
  % TODO esto es más un beneficio de REST que de otra cosa
  \item The data can be reused by other applications or even other spaces. % Interop!
        These applications would not be required to use a space-based approach.
        Therefore, they will not depend on the correct functioning of our whole system. % del servidor central
  \item Carrying that information can be useful in certain mobility situations.
        For example, let a us imagine a person which stores her user profile in the smartphone.
        She could share it with different spaces or applications as it moves along the city.
\end{itemize}


% Aún así, que los dispositivos se coordinen a través de una entidad central es conveniente:
%       Sencillo de implementar: notificaciones, razonamiento, etc.
%       Incluso si ese espacio luego está distribuído o cambia de máquina, acceso a través de dicha interfaz (HTTP o CoAP el día de mañana)
%       Modo: caching (para reliability) o modo ver qué hay en el espacio ahora mismo (visión en tiempo real)
%       -->> INDEPENDENCIA DE LOCALIZACIÓN!!!
Still, most of the \ac{iot} devices or mobile phones are unreliable: they can join and leave at any moment.
Therefore, distributing the shared space among unreliable nodes comes with a number of drawbacks:
\begin{itemize}
  \item This unreliability makes difficult to maintain the consistency of the space. % TODO CUIDADO, puedo estar metiendome en un fregado, la parte de los dispositivos no será consistente!
        Since this information drives the coordination between the devices, its consistency is important.
  \item A blocking mechanism is important in space-based computing.
        For example, a worker node may block until some task is become available in the space.
        A way to implement it in a distributed space is by means of a notification system.
        Again, implementing it using unreliable devices is hard to implement. % no sé si esto último no sonará demasiado a mofa...
  \item And last but not least, if the access to some data in the space cannot be guaranteed no matter if the device which wrote that information is available, there will not be \emph{time uncoupling}.
\end{itemize}
Overcoming the previous difficulties, usually implies a high network traffic.
However, this negatively influences the energy consumption of nodes whose energetic autonomy might be limited.


\subsection{A Halfway Solution}
\label{sec:halfway_solution}

In this thesis, we propose to conserve the desirable characteristics of both \ac{rest} and \ac{tsc} by mixing them.

On the one hand, we propose a uniform access to the space by the \acs{http} \ac{api} described previously.
The space can then be distributed using any existing approaches. % TODO cite
However, for the sake of clarity, we will assume that each space is managed by a unique server.

On the other hand, each space will be enriched by the data provided by various autonomous providers.
These providers might be any kind of mobile or embedded device, no matter how limited they are.
This \emph{enrichment} can be materialized:
\begin{enumerate}[(a)]
  \item Considering additional data in a reasoning process triggered when a primitive is called.
  \item Including additional data as a response.
        For example, a graph read from an embedded device could be returned as a response to a primitive.
\end{enumerate}
In this thesis, we have focused on the latter alternative.


To do that, we propose an extension of the already presented \ac{tsc} model by means of new concepts, new primitives and new behavior.
Figure~\ref{fig:new_model} presents the key elements of this new model.


\InsertFig{new_model}{fig:new_model}{
  Key concepts of the new \ac{tsc} model presented.
}{
  The coordination space, is where the graphs can be written, read and taken by any participant.
  The coordination space is hold by a device called \emph{coordinator}.
  The current view of all the \emph{self-managed graphs} in the space forms the \emph{outer space}.
  Therefore, the \emph{outer space} is hold by many devices (also called \emph{asteroids}).
  The \ac{tsc} \ac{http} \ac{api} corresponds with the generic \ac{tsc} to access to the primitives presented in Section~\ref{sec:align_tsc_http}.
  The \emph{OSAPI} is the \ac{api} which must be implemented by any node willing to share \emph{self-managed graphs}.
}{1}{}


% grafos autogestionados (no takeables por otros) => write en local
\subsubsection{Self-managed graphs}

These graphs are the ones which are managed by the device, called \emph{asteroid}, which provides them to the rest.
In other words, self-managed graphs enrich the space in the ways previously described, but they cannot be removed.
% poner ejemplo de por qué no tiene sentido que eliminen a través del espacio
Therefore, they are \emph{second-class graphs} which provide information about the environment but cannot be used for coordination purposes.

% write locally
% No device can remove them apart from their creator. % TODO o si puede serlo, esta no lo decide el sistema
The \emph{asteroid} makes these graphs accessible to others through \ac{http}.
% objetivo: que se pueda acceder a estos grafos incluso si no son parte de nuestra app => interop
The final goal is to potentially allow to reuse the data provided by any existing \ac{rest}ful service. % app level interop
Therefore, the \ac{api} should be or trend to be \ac{rest}ful.
% para ello es importante usar un RESTful approach, como sabemos que es complejo ofrecemos otra opción en el siguiente capítulo
However, we leave the \emph{hypermedia} \ac{api} as a future work.
Instead, we require a mandatory \emph{OSAPI} to be implemented in each \emph{asteroid} to guarantee access to the \emph{self-managed graphs}.
% lo sé, no está justificado 0:-)



\subsubsection{New primitives}

To make the most of the information in a space, we propose a new primitive to query all over the semantic information stored.
The \ac{rest}fulness of this primitive could be argued since it does not operate at resource level, but mixing several resources.
However, we believe that it is useful to have an endpoint for the queries which involve many graphs.
\citet{kjernsmo_necessity_2012} discusses this topic in depth. % TODO Mirar otras citas???

This new primitive is defined as follows:
\begin{itemize}
  \item The \textbf{query} primitive aims to see the space as a whole, returning all the triples matching the given template.
  
  \begin{lstlisting}
    query(space_URI,template): triples          [6]
  \end{lstlisting}
\end{itemize}


The Table~\ref{tab:queryAPI} extends Table~\ref{tab:tscAPI} to include this new primitive.
% TODO otra clave: debería no tener porqué pasar por el servidor

\begin{table} %http://en.wikibooks.org/wiki/LaTeX/Floats,_Figures_and_Captions#Wide_figures_in_two_column_documents
  \centering
  \caption {
    \acs{http} mapping for the primitives detailed in the Section~\ref{sec:primitives}. \textit{sp} is a space \acs{uri},
    \textit{g} is a graph \acs{uri}, \textit{s}, \textit{p} and \textit{o-uri} are subject, predicate and object \acsp{uri} or wildcards (represented with an as \textit{*}).
    When the template's object is a literal, it can be expressed specifying its value (\textit{o-val}) and its type (\textit{o-type}).
    \medskip
  }
  \begin{tabular}{c|l|c}
      \acs{http} request & \acs{url} & Returns \\
      \hline
      GET & \{sp\}/query/wildcards/\{s\}/\{p\}/\{o-uri\} &  [6] \\
      & \{sp\}/query/wildcards/\{s\}/\{p\}/\{o-type\}/\{o-val\} & \\
  \end{tabular}
  \label{tab:queryAPI}
\end{table}


A key point of the \ac{api} is that the \emph{asteroids} might not even follow the \ac{tsc} paradigm.
For instance, the \emph{OSAPI} can encapsulate data provided by a third middleware.
However, a primitive to ease that management can be a convenient for the developers which do not need a more customized behavior.
With that in mind, we propose another writing primitive.
This primitive only has local effects and therefore has no HTTP equivalent:
\begin{itemize}
  \item The \textbf{write\_self} primitive writes a \emph{self-managed graph} and returns an \ac{uri} which identifies it.
  
  % tiene sentido definir el space_URI???
  % mejor definir su propio espacio?
  % tiene sentido especificar su URI? write_self(graph_URI, triples): URI
  \begin{lstlisting}
    write_self(space_URI, triples): URI
  \end{lstlisting}
\end{itemize}



\subsubsection{New behaviors}

% explicar cómo se escribe y lee en el espacio
% solución enfoque híbrido:
%      cambios en actuadores => directamente a través de HTTP o indirectamente a través de tasks escritas en espacio
%                               o mejor: podrían esas tasks ser directamente esos servicios???
%      grafos que sí => write al "servidor HTTP"
%      query => en todos los dispositivos (capítulo 4) - Porque a veces es necesario a través de todos los nodos
%      take + read => sobre los grafos takeables (o inferencia con toda la info del espacio, cómo prefieras)
In this section we will try to clarify how the different behaviors coexist.

\paragraph{Writing}

The most basic writing primitive allows a client to write a graph into the space hold by the server.
However, we also presented the \emph{write\_self} primitive.
\emph{Write\_self} writes into the local device a untakeable graph (i.e. self-managed graph).
% TODO comprobar una vez acabado que es así!
Finally, in Chapter~\ref{cha:actuate} we argue that a third \emph{writing} primitive is necessary.
This primitive should allow to \emph{suggest} physical changes in the space through actuators.


\paragraph{Reading}

\emph{Query} performs a traversal query which aggregates all the graphs of the space.
\emph{read} and \emph{take} work at resource level.
However, we will also consider \emph{self-managed graphs} to enrich the \emph{read} primitive. % mediante redirect o lo que sea