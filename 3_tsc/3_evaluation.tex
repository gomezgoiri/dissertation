\section{Conclusions}

With the solution presented in the previous section, we aimed to retain the desirable properties of both \ac{rest} and \ac{tsc}.
% analísis más largo en la siguiente sección
% 1. cómo sé que esto es mejor que usar REST y TSC por separado? Sinergia?
% 2. que aporta unirlo bajo un mismo middleware?
% 3. tiene beneficios?
However, some questions arise from that integration:
(1) does in fact retain all the properties of \ac{rest} and \ac{tsc} separately? Otherwise, which properties are affected?
(2) what other benefits carries comparing with using existing \ac{tsc} and \ac{rest} middleware?

% TODO
%   features de REST que no aportan mucho:
%        UP Performance
%   features añadidas por TSC (valuable properties aportadas)
%       utiles para IoT
%   qué propiedades deseables para IoT añadiría TSC (per se)
%   hablar sobre las propiedades de IoT!!!


\subsection{Network-based Style} % Architectural Properties for Network-based Styles
\label{sec:network_properties}
% Cómo afecta la app propuesta => ir actualizando al final de otras secciones???

In Section~\ref{sec:tsc_vs_rest} we have described how \ac{tsc} does not contradict any of the \ac{rest} principles.
However, the adaptation presented in this thesis does not completely adheres to the \ac{rest} style.
In this section we present how this divergences affect the \ac{rest}'s properties.
% decir que el objetivo final es que pudiera ser REST

% TODO antes de entrar al lio, explicar cómo funciona esto de REST, en qué parte de nuestra solución lo necesitaremos
% decir que API para TSC mola
% decir que API para los cacharros deberia de ser independiente a lo que nosotros digamos y por eso estaria bien REST
%     de todas formas, como es dificil, nos quedamos en un nivel de madurez menor


In \citeauthor{fielding_architectural_2000}'s words, the relevant properties which describe a network-based system are the following ones \footnote{We refer to the reader to \citet{fielding_architectural_2000} for the complete thorough analysis.}:
% verificar que no se parece demasiado a sus definiciones o sino poner cursiva.
\begin{description}
  \item[Performance] is divided into network performance, user-perceived performance and efficiency.
		    The first is affected by the styles in the number of interactions and the granularity of data elements.
		    The second property refers to the impact a user in front of an application perceives.
		    The third is achieved by minimizing the use of the network.
  \item[Scalability] measures how an architecture supports a big amount of components and interactions between them.
  \item[Simplicity] is achieved through the separation of concerns for the components and the generality of architectural elements.
  \item[Modifiability] encompasses evolvability, extensibility and customization.
		      The first refers to the degree in which a component can be implemented without negatively impacting on others.
		      The second measures the ability to add functionality to the system.
		      The third is the ability to customize the behavior of an architectural element temporarily.
  \item[Configurability] is related with the extensibility and the reusability.
  \item[Reusability] is the ability to reuse components, connectors or data elements without modifying other apps.
  \item[Visibility] is the ability of a component of monitoring or mediating in the interaction between other two components.
  \item[Portability] is the ability of working in different environments.
  \item[Reliability] is the degree in which an architecture depends on the failures of the system or components, connectors or partially incorrect data.
\end{description}

% Requisitos de ealy web, propiedades deseables
%   Low entry-barrier
%   Extensibilidad
%   Distributed Hypermedia
%   Internet-scale

The Table~\ref{tab:network_properties} summarizes how different architectural styles achieve these properties.
Particularly, it shows the styles from which \ac{rest} derives (see Section~\ref{sec:rest}).
The ultimate goal of the solution explained in the previous section is twofold:
\begin{enumerate}
  \item Provide a \ac{rest} access to a semantic space.
       This would ease its integration with the rest of the web.
  \item Enrich that space with the knowledge provided by other \ac{rest} \acp{api}.
\end{enumerate}
Therefore, ideally, its networking properties would be the sames as the \ac{rest} style.


However, defining a 100\% \ac{rest} compliant \ac{api} is not easy.
Indeed, most of the self-proclaimed \ac{rest}ful \acp{api} are not \citep{house_how_2012}. % la nueva buzz word para eso: hypermedia API
The main cause is the \emph{HATEOAS} constraint seen in the Section~\ref{sec:rest} \citep{fielding_rest_2008}.
Using \ac{http} as an application-level protocol forces a developer to comply the rest of the constraints \citet{moore_hypermedia_2010}, but not \emph{HATEOAS}.
% The Richardson Maturity model habla de eso! Lo mencionan bastante.


% semantic-based \ac{api} is not easy. => referencias a los que lo han intentado, a que no hay hipertexto, a que te puede interesar inferir con bastantes
Regarding the \ac{sw}, some recent efforts have tried to move closer to the \ac{hypermedia} constraint \citep{steiner_fulfilling_2011,kjernsmo_necessity_2012}.
However, these worlds remain quite isolated.
In fact, \ac{sw} API  usually present another main divergence with the \ac{rest} style: the use of query endpoints.
% i.e. no devuelven listas de enlaces, sino todo a lo bruto
% esto quiere decir que no se devuelve todo y ala, tu procesa esa burrada de datos, más bien se filtran
These endpoints intend to solve some inefficiency issues which \ac{rest} shows when working with a big amount of data. % TODO mencionar \ac{lod} en algún punto de aquí?
To that end, they allow expressive query languages and offer results where the boundaries of the different resources often blurs \citep{wilde_restful_2009}.
The most paradigmatic case may be to decide to which graph does a inferred content belongs. % ejemplo de lo anterior


% Aterrizar esto a IoT y a nuestro caso:
%        La eficiencia es importante => para evitar hacer 500 llamadas a un cliente
%        La reusabilidad es importante también => para potencialmente adaptarse a cualquier WoT semántico
%           en el futúro => más trabajo en este área
%       Solución de compromiso:
%           nivel de madurez X de Richardson. Suponemos que alguien debe serguir nuestro API mínimo en los objetos WoT



% tratamos de mezclar un API REST (TSC) con otras (la facilitada por cada nodo)
% U es el principal aspecto de rest, y también el más complejo de cumplir
% U => lo que más se "viola"
%      REP => query
%      HATEOAS => se viene haciendo trabajo para solucionar esto
%                 la solución propuesta en el siguiente capítulo no es HATEOAS
%      However, we do acknowledge that further work has to be done in certain aspects such as the \emph{HATEOAS} aspect of semantic \acp{api}.

% REPERCUSIONES DE ESO EN PROPIEDADES:

% condiciones de REST que no cumpliría
% qué aportaría

% TODO Comprobar que no se salga por el borde derecho!
\input{\pathchapthree/tables/network_properties}


\subsection{Middleware Properties}

% explicar cómo HTTP trataba de evitar complejidades
% explicar como al crear una capa por encima, complicas todo un poco
%       sencillez
%       user-based library vs a lo otro

% Propiedades que jodes de HTTP de cara al usuario: simplicidad...
% propiedades de cara al usuario:
% Requisitos de ealy web, propiedades deseables
%   Low entry-barrier
%   Extensibilidad
%   Distributed Hypermedia
%   Internet-scale


\subsection{Querying Distributedly over the Space}
% TODO condiciones relajadas: consistencia, razonamiento distribuído
% out of the scope: cómo implementarlo
% optaremos por lo más sencillo


% condiciones de TSC que no cumpliría
% condiciones que hemos relajado de TSC (i.e. limitaciones)
%     1. autonomía espacial (dependes de un nodo)
%     2. consistencia de datos introducidos en el espacio
%     3. cómo asegurar un take?
%     4. subscripciones
%     + Hemos juntado como 2 mundos: TSC y WoT
%        La mayoría de las contribuciones son aplicables a WoT
%        El mecanismo de búsqueda no es Hypertext driven! (no?)
%        Por que sería muy costoso hacer rollo araña?!
%     5. Future work:
%          definir datos como consumibles por otros nodos o no
%          eliminar la necesidad de espacios?         
%     por qué creemos que sigue siendo útil?



\subsection{Summary}

In the previous sections we have get to the bottom of the strengths and weaknesses of our proposal.
To sum up, the main limitations are X and Y.
On the other hand, we can XXX.
Table~\ref{x} shows these and other aspects.

% Ventajas de meclar 2 cosas aparentemente separadas?
%   Para WoT:
%      comunicación indirecta para cacharros
%          local+ref
%              de contenidos relativos a coordinación
%              podríamos cachear contenidos de otros en el espacio central (reliability+energy)
%          ref
%              sacar a colación los problemas aquellos de query sobre muchos recursos
%
%   Para TSC (respecto a otras como Smart-M3):
%      limitamos qué gestiona la entidad central => sólo coordinación, el resto lo coge de los cacharros
%      se reconoce su autonomía permitiendo gestionarse su propio contenido => REST, escalabilidad
%      interop => SW y posibilidad de extender a otros servicios REST
%      multiplataforma => facilidad para portarlo
%
%   Para desarrollador:
%      API integrada y simple





\section{\acs{wot} and \acs{tsc} Comparison}
% 2. Comparativa
\label{sec:wot_tsc_comparison}

% TODO rehacer taaanto :-)

In this section, the strengths and weaknesses of both \ac{tsc} and REST approaches will be discussed and compared.
Then, their compatibility is shown by proposing two ways to use \ac{wot} solutions inside a \ac{tsc} environment and \textit{viceversa}.

The similarities and differences between \ac{wot} and \ac{tsc} which are summarized in the Table \ref{tab:comparison} are detailed below.

\begin{table}[ht!]
\centering
\caption {Comparison between \ac{wot} and \ac{tsc} (OtsoPack) resource-oriented approaches}
\begin{tabular}{|l|p{2,4cm}|p{2,6cm}|}
\hline
& \ac{wot} & \ac{tsc} (OtsoPack) \\
\hline
\textit{Architecture} & ROA \& C/S & ROA \& P2P \\
\textit{Communication} & HTTP & Jxta \\
\textit{Operations} & HTTP verbs & \ac{tsc} primitives \\
\textit{Format} & HTML, JSON \& XML & RDF (NTriples) \\ %content negotiation
\textit{Developer aid} & Less expressive data \& specific use & Expressiveness \& uniform API \\
\textit{Coupling} & Low & Very low \\ %data
\textit{Discovery} & Bad & Very good \\
\textit{Scalability} & Good & Bad \\
\textit{Semantics} & Microformats & Full \\
\hline
\end{tabular}
\label{tab:comparison}
\end{table}

\subsection{Architecture}
Both approaches are based on resource oriented architectures. \ac{wot} uses the REST architectural style, where the contents are directly addressable by
URLs to manipulate them, and \ac{tsc} creates, removes and modifies RDF triples or graphs, i.e. sets of interlinked triples, in a space formed by peers
in a P2P network.

Despite of these similarities, \ac{wot} uses a client-server architecture where each client has to know the URL where to address its operations, while
\ac{tsc} relies on a distributed shared memory which makes each process within a space completely autonomous. In \ac{tsc}, a node does not need to know where
information is stored, just the URI of the space it wants to query. Furthermore, the OtsoPack solution is fully distributed and conceived not to depend
on any centralized, previous known, intermediary server.

\subsection{Communication protocol}
Our \ac{tsc} solution currently uses Jxta\footnote{http://jxta.kenai.com/}, a language and platform independent \textit{Peer to Peer} protocol, to
interconnect the nodes and manage the groups (spaces) where they belong. Unfortunately, the mobile version relies in a Jxta gateway called Rendezvous
to propagate the messages to other nodes of the group, making some previous configuration necessary and potentially creating a bottleneck. Anyway,
some \ac{tsc} implementations such as TripCom\footnote{TripCom (IST-4-027324-STP, www.tripcom.org)} rely on HTTP, and one of our next steps will be the
reimplementation of our network communication through HTTP.

Even if it is not mandatory to comply with the RESTful style, \ac{wot} usually employs the HTTP protocol as a communication layer because of its
simplicity and wide adoption to ensure ample deployment.

\subsection{Operations}
\ac{wot} uses HTTP verbs to retrieve, create, modify or delete web resources. Retrieval is done using HTTP GET, creation by means of HTTP POST,
modifications with HTTP PUT and removals with HTTP DELETE. Finally, the HTTP OPTIONS command is used to introspectively find out what operations are
allowed for any URL.

\ac{tsc} and tuplespace solutions offer different primitives to write, read and delete content. In our solution, the previously explained \textit{write},
\textit{read} and \textit{take} primitives do that. Apart from these primitives, other ones are provided to manage spaces, to claim the manager role
for a type of content in a space, event notification or traditional request-reply style service consumption. Anyway, in this thesis we are going to focus in the
first ones because they are inherent to the \ac{tsc} paradigm. % innecesario mencionarlo?

\subsection{Format}
\ac{wot} usually returns a human readable HTML representation for a resource and XML or JSON common web representations to be used in mashups. One of the
key mechanisms that \ac{wot} inherits from HTTP is \textit{content negotiation}, which enables clients and servers to negotiate the requested and
provided representations for any given resource.

\ac{tsc} does not provide this response format negotiation mechanism. So, OtsoPack interchanges data in N-Triples format, which is the most primitive
representation of semantic data. In any case, other alternative semantic representations (e.g. RDF/XML, OWL/XML, Turtle or N3) could be
easily adopted as they basically describe the same RDF triples under different textual wrappers.

\subsection{Developer aid}%Actors}
In ROA an agreement about the data being exchanged and how it can be accessed is needed to develop applications.
On the one hand, \ac{wot} can define machine processable data using XML or JSON, but thanks to the Semantic Web \ac{tsc} can go one step
further formally defining them and making them also ``machine understandable'' (i.e. it is capable of inferring new knowledge and make
high-level queries over it).

On the other hand, both \ac{wot} and \ac{tsc} offer some operations and interfaces to access them. Whereas in \ac{tsc} this interface is the same in each node
and it is closely related with \ac{tsc} operations and resources, in \ac{wot} it changes in each application making a previous learning process necessary
to use them.

%Although applications which do not require human intervention can be built using RESTful services, one of the core concepts of \ac{wot} is the
%browse-ability of the object by the user using HTML. \ac{tsc} is a solution for the Semantic Web, which aims to provide a machine understandable
%web using ontologies and defining properties to enable inference.

\subsection{Coupling}
\label{sec:coupling}
The REST style describes loosely coupled services due to the platform independent, asynchronous and few self describing messages
\citep{pautasso_why_2009}. In a very similar manner, \ac{tsc} offers different kind of autonomies \citep{krummenacher_www_2005}:
\textit{time autonomy} (because of its asynchronous nature), \textit{location autonomy} (information providers and consumers are independent
from where the data is stored), \textit{reference autonomy} (nodes do not need to know each other) and
\textit{data schema autonomy} (it follows the RDF specification making it independent of nodes internal data schema).
% Quitado de la introducción para no repetirme
%Remarkably, \ac{tsc} guarantees four basic types of autonomies: \textit{space autonomy} (processes can be run in very different computational
%environments such as Android, Java ME devices or PCs, they just use a common coordination language), \textit{reference autonomy}
%(nodes do not need to know each other), \textit{time autonomy} (they communicate asynchronously) and \textit{data schema autonomy} (since
%written and read data is based on RDF triples, \ac{tsc} nodes are independent of their internal data schemas) \citep{fensel_triple-space_2004}.

In spite of the outlined decoupling nature of both approaches, the data definition can be considered a coupling mode indeed.
While in \ac{wot} each resource defines its own data formats and contents themselves, in \ac{tsc} the ontology in which the semantic
concepts are described must be known by each part of a distributed application to effectively cooperate among them.

\subsection{Discovery}
One of the main drawbacks in \ac{wot} is the lack of a discovery mechanism for new objects and the data they provide. Even when this data can be linked
in each object response (using HATEOAS) and microformats are sometimes included to ease the search-ability of these objects by search engines, it is difficult for an
object which may change of location and context to be referred. Thus, \ac{wot} may have a tendency to create isolated islands of data. Several workarounds
have been proposed to overcome this limitation, such as using a central repository\footnote{http://www.pachube.com/}, a framework which uses federated
repositories responsible for different administrative domains \citep{stirbu_towards_2008} or making each connected sensor announce itself to let an
intermediary know its presence \citep{kamilaris_smart_2010}.

\ac{tsc} provides a transparent data level discovery mechanism to the user since when a node joins a space (i.e. a group), its data become queriable by any other
node joint to this space. In OtsoPack the space management and communication relies on Jxta, a protocol which can be used at any level (even if we
have mainly used it on local environments using Jxta's discovery layer's capabilities).

\subsection{Scalability}
% TODO reescribir
The scalability of \ac{wot} is argued to be well proved since the World Wide Web is the most practical scalable system. As many objects as
necessary could be added to WWW without making it worse. 

Although Jxta scalability has been discussed and addressed in several works \citep{antoniu_performance_2007}, since our solution is fully decentralized
and uses flooding (each query is spread to the rest of the peers which belong to a space), its scalability is expected to be poor. To overcome this limitation,
we are working on implementing Semantic Overlay Networks (SON) to let the objects automatically divide the spaces into smaller ones and address queries
just to the appropriate nodes which conform a semantically related space.

% \begin{figure} [htbp]
% 	\centering
% 		\includegraphics[width=\linewidth]{./img/esquemaSON/arquitectura.png}
% 	\caption{Proposed distributed SON-based solution.}
% 	\label{fig:changeToSON}
% \end{figure}
% 
% As can be appreciated in Figure \ref{fig:changeToSON}, the proposed solution aims to split the spaces up into smaller subspaces.
% To do so, semantically similar contents are placed together in the same subspaces. E.g. \textit{subspaceA} contains \textit{graph1}
% and \textit{graph2} which describe ``light'' related knowledge. In the meantime, the nodes from the original space (\textit{space1}) can organize
% themselves to create another \textit{subspaceB} containing the relevant data for describing ``mobile phones''.

\subsection{Semantics}
On the one hand, \ac{wot} uses predefined microformats to embed semantic information into human readable pages. Doing so, the search process performed
by search engines is enhanced \citep{guinard_internet_2011}. On the other hand, \ac{tsc} allows the usage of full semantics, more expressive than microformats,
using RDF as a base. This makes \ac{tsc} capable of using standard query languages such as SPARQL and it becomes also independent of third parties' products to search data.



% 3. Ventajas ppales de cada uno
\subsection{Conclusion}
% TODO

In the previous section, the two-way compatibility between the \ac{tsc} and \ac{wot} approaches has been described. As has been shown, \ac{wot} is good due to its
scalability and usage of web standards, which makes it easy to be understood by potential developers (which encourages its usage). Our \ac{tsc}
solution, on the other hand, provides good local discovery of new resources and their information and allows more expressive semantic data
definition which leads to more expressive and sophisticated queries. Taking this into account, a scenario which takes advantage of the potential
combination of these approaches has been sketched (see Figure \ref{fig:scenario}).